"use client";

// src/lib/base-client.ts
var ApiError = class extends Error {
  constructor(code, message, details, status) {
    super(message);
    this.code = code;
    this.details = details;
    this.status = status;
    this.name = "ApiError";
  }
};
var BaseApiClient = class {
  baseUrl;
  apiKey;
  timeout;
  defaultHeaders;
  constructor(config) {
    this.baseUrl = config.baseUrl.replace(/\/$/, "");
    this.apiKey = config.apiKey;
    this.timeout = config.timeout || 3e4;
    this.defaultHeaders = {
      "Content-Type": "application/json",
      ...config.headers
    };
    if (this.apiKey) {
      this.defaultHeaders["X-API-KEY"] = this.apiKey;
    }
  }
  /**
   * Creates a safe response for no-content scenarios (204 responses)
   * Returns a sensible default based on common API patterns
   */
  createNoContentResponse() {
    return { success: true };
  }
  async request(method, path, options) {
    let url;
    if (this.baseUrl) {
      url = new URL(`${this.baseUrl}${path}`);
    } else if (typeof window !== "undefined" && window.location) {
      url = new URL(path, window.location.origin);
    } else {
      url = new URL(path, "http://localhost:3000");
    }
    if (options?.params) {
      Object.entries(options.params).forEach(([key, value]) => {
        if (value !== void 0 && value !== null) {
          url.searchParams.append(key, String(value));
        }
      });
    }
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);
    try {
      const headers = {
        ...this.defaultHeaders,
        ...options?.config?.headers,
        ...options?.headers
      };
      if (options?.body instanceof FormData) {
        delete headers["Content-Type"];
      }
      const response = await fetch(url.toString(), {
        method,
        headers,
        body: options?.body instanceof FormData ? options.body : options?.body ? JSON.stringify(options.body) : void 0,
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (response.status === 204 || response.headers.get("content-length") === "0") {
        return this.createNoContentResponse();
      }
      let jsonData;
      try {
        jsonData = await response.json();
      } catch (error) {
        if (response.ok) {
          return this.createNoContentResponse();
        } else {
          throw new ApiError(
            "PARSE_ERROR",
            "Failed to parse response as JSON",
            void 0,
            response.status
          );
        }
      }
      if (!response.ok) {
        const error = jsonData?.error || {
          code: "HTTP_ERROR",
          message: `HTTP ${response.status}: ${response.statusText}`
        };
        throw new ApiError(error.code, error.message, error.details, response.status);
      }
      if (jsonData && typeof jsonData === "object" && "success" in jsonData) {
        const apiResponse = jsonData;
        if (!apiResponse.success) {
          const error = "error" in apiResponse ? apiResponse.error : {
            code: "UNKNOWN_ERROR",
            message: "An unknown error occurred"
          };
          throw new ApiError(error.code, error.message, error.details, response.status);
        }
        return apiResponse.data;
      } else {
        return jsonData;
      }
    } catch (error) {
      clearTimeout(timeoutId);
      if (error instanceof ApiError) {
        throw error;
      }
      if (error instanceof Error) {
        if (error.name === "AbortError") {
          throw new ApiError("TIMEOUT", "Request timed out");
        }
        throw new ApiError("NETWORK_ERROR", error.message);
      }
      throw new ApiError("UNKNOWN_ERROR", "An unknown error occurred");
    }
  }
  async get(path, options) {
    return this.request("GET", path, options);
  }
  async post(path, body, options) {
    return this.request("POST", path, { ...options, body });
  }
  async put(path, body, options) {
    return this.request("PUT", path, { ...options, body });
  }
  async patch(path, body, options) {
    return this.request("PATCH", path, { ...options, body });
  }
  async delete(path, options) {
    return this.request("DELETE", path, options);
  }
};

// src/services/agents.ts
var AgentsService = class extends BaseApiClient {
  /**
   * List all agents with minimal details
   */
  async listAgents() {
    return this.get("/api/agents");
  }
  /**
   * Get specific agent details
   */
  async getAgent(agentId) {
    return this.get(`/api/agents/${agentId}`);
  }
  /**
   * Create a new agent
   */
  async createAgent(params) {
    return this.post("/api/agents", params);
  }
  /**
   * Update an existing agent
   */
  async updateAgent(agentId, params) {
    return this.patch(`/api/agents/${agentId}`, params);
  }
  /**
   * Delete an agent
   */
  async deleteAgent(agentId) {
    return this.delete(`/api/agents/${agentId}`);
  }
  /**
   * Start an existing agent
   */
  async startAgent(agentId) {
    return this.post(`/api/agents/${agentId}/start`);
  }
  /**
   * Stop a running agent
   */
  async stopAgent(agentId) {
    return this.post(`/api/agents/${agentId}/stop`);
  }
  /**
   * Get all available worlds
   */
  async getWorlds() {
    return this.get("/api/agents/worlds");
  }
  /**
   * Add agent to a world
   */
  async addAgentToWorld(agentId, worldId) {
    return this.post(`/api/agents/${agentId}/worlds`, { worldId });
  }
  /**
   * Update agent's world settings
   */
  async updateAgentWorldSettings(agentId, worldId, settings) {
    return this.patch(`/api/agents/${agentId}/worlds/${worldId}`, { settings });
  }
  /**
   * Get agent's plugin panels
   */
  async getAgentPanels(agentId) {
    const response = await this.get(
      `/api/agents/${agentId}/panels`
    );
    const panels = (Array.isArray(response) ? response : []).map((panel, index) => ({
      id: `${panel.name}-${index}`,
      // Generate an ID since server doesn't send one
      name: panel.name,
      url: panel.path,
      type: "plugin"
    }));
    return { panels };
  }
  /**
   * Get agent logs
   */
  async getAgentLogs(agentId, params) {
    return this.get(`/api/agents/${agentId}/logs`, { params });
  }
  /**
   * Delete a specific log entry
   */
  async deleteAgentLog(agentId, logId) {
    return this.delete(`/api/agents/${agentId}/logs/${logId}`);
  }
  /**
   * Get agents associated with a server
   */
  async getAgentsForServer(serverId) {
    return this.get(
      `/api/messaging/servers/${serverId}/agents`
    );
  }
  async addAgentToServer(serverId, agentId) {
    return this.post(`/api/messaging/servers/${serverId}/agents`, { agentId });
  }
  async removeAgentFromServer(serverId, agentId) {
    return this.delete(`/api/messaging/servers/${serverId}/agents/${agentId}`);
  }
  async getServersForAgent(agentId) {
    return this.get(
      `/api/messaging/agents/${agentId}/servers`
    );
  }
};

// src/services/messaging.ts
var MessagingService = class extends BaseApiClient {
  /**
   * Submit agent replies or system messages
   */
  async submitMessage(params) {
    return this.post("/api/messaging/submit", params);
  }
  /**
   * Notify message completion
   */
  async completeMessage(params) {
    return this.post("/api/messaging/complete", params);
  }
  /**
   * Ingest messages from external platforms
   */
  async ingestExternalMessages(params) {
    return this.post("/api/messaging/ingest-external", params);
  }
  /**
   * Create a new channel
   */
  async createChannel(params) {
    return this.post("/api/messaging/central-channels", params);
  }
  /**
   * Create a group channel
   */
  async createGroupChannel(params) {
    return this.post("/api/messaging/central-channels", params);
  }
  /**
   * Find or create a DM channel
   */
  async getOrCreateDmChannel(params) {
    return this.get("/api/messaging/dm-channel", { params });
  }
  /**
   * Get channel details
   */
  async getChannelDetails(channelId) {
    return this.get(`/api/messaging/central-channels/${channelId}/details`);
  }
  /**
   * Get channel participants
   */
  async getChannelParticipants(channelId) {
    return this.get(
      `/api/messaging/central-channels/${channelId}/participants`
    );
  }
  /**
   * Add agent to channel
   */
  async addAgentToChannel(channelId, agentId) {
    return this.post(`/api/messaging/central-channels/${channelId}/agents`, {
      agentId
    });
  }
  /**
   * Remove agent from channel
   */
  async removeAgentFromChannel(channelId, agentId) {
    return this.delete(
      `/api/messaging/central-channels/${channelId}/agents/${agentId}`
    );
  }
  /**
   * Delete a channel
   */
  async deleteChannel(channelId) {
    return this.delete(`/api/messaging/central-channels/${channelId}`);
  }
  /**
   * Clear channel history
   */
  async clearChannelHistory(channelId) {
    return this.delete(
      `/api/messaging/central-channels/${channelId}/messages`
    );
  }
  /**
   * Post a new message to a channel
   */
  async postMessage(channelId, content, metadata) {
    return this.post(`/api/messaging/central-channels/${channelId}/messages`, {
      content,
      metadata
    });
  }
  /**
   * Get channel messages
   */
  async getChannelMessages(channelId, params) {
    return this.get(
      `/api/messaging/central-channels/${channelId}/messages`,
      { params }
    );
  }
  /**
   * Get a specific message
   */
  async getMessage(messageId) {
    return this.get(`/api/messaging/messages/${messageId}`);
  }
  /**
   * Delete a message from a channel
   */
  async deleteMessage(channelId, messageId) {
    return this.delete(
      `/api/messaging/central-channels/${channelId}/messages/${messageId}`
    );
  }
  /**
   * Update a message
   */
  async updateMessage(messageId, content) {
    return this.patch(`/api/messaging/messages/${messageId}`, { content });
  }
  /**
   * Search messages
   */
  async searchMessages(params) {
    return this.post("/api/messaging/messages/search", params);
  }
  /**
   * List all message servers
   */
  async listServers() {
    return this.get("/api/messaging/central-servers");
  }
  /**
   * Get server channels
   */
  async getServerChannels(serverId) {
    return this.get(
      `/api/messaging/central-servers/${serverId}/channels`
    );
  }
  /**
   * Create a new server
   */
  async createServer(params) {
    return this.post("/api/messaging/servers", params);
  }
  /**
   * Sync server channels
   */
  async syncServerChannels(serverId, params) {
    return this.post(
      `/api/messaging/servers/${serverId}/sync-channels`,
      params
    );
  }
  /**
   * Delete a server
   */
  async deleteServer(serverId) {
    return this.delete(`/api/messaging/servers/${serverId}`);
  }
  /**
   * Update a channel
   */
  async updateChannel(channelId, params) {
    return this.patch(
      `/api/messaging/central-channels/${channelId}`,
      params
    );
  }
  /**
   * Generate channel title
   */
  async generateChannelTitle(channelId, agentId) {
    return this.post(
      `/api/messaging/central-channels/${channelId}/generate-title`,
      { agentId }
    );
  }
  /**
   * Add user to channel participants (implemented via updateChannel)
   */
  async addUserToChannel(channelId, userId) {
    const channel = await this.getChannelDetails(channelId);
    const currentParticipants = channel.metadata?.participantCentralUserIds || [];
    if (!currentParticipants.includes(userId)) {
      const updatedParticipants = [...currentParticipants, userId];
      return this.updateChannel(channelId, {
        participantCentralUserIds: updatedParticipants
      });
    }
    return { success: true, data: channel };
  }
  /**
   * Add multiple users to channel participants (implemented via updateChannel)
   */
  async addUsersToChannel(channelId, userIds) {
    const channel = await this.getChannelDetails(channelId);
    const currentParticipants = channel.metadata?.participantCentralUserIds || [];
    const newParticipants = [...currentParticipants];
    for (const userId of userIds) {
      if (!newParticipants.includes(userId)) {
        newParticipants.push(userId);
      }
    }
    return this.updateChannel(channelId, {
      participantCentralUserIds: newParticipants
    });
  }
  /**
   * Remove user from channel participants (implemented via updateChannel)
   */
  async removeUserFromChannel(channelId, userId) {
    const channel = await this.getChannelDetails(channelId);
    const currentParticipants = channel.metadata?.participantCentralUserIds || [];
    const updatedParticipants = currentParticipants.filter((id) => id !== userId);
    return this.updateChannel(channelId, {
      participantCentralUserIds: updatedParticipants
    });
  }
};

// src/services/memory.ts
var MemoryService = class extends BaseApiClient {
  /**
   * Get agent memories
   */
  async getAgentMemories(agentId, params) {
    return this.get(`/api/memory/${agentId}/memories`, { params });
  }
  /**
   * Get room-specific memories
   */
  async getRoomMemories(agentId, roomId, params) {
    return this.get(`/api/memory/${agentId}/rooms/${roomId}/memories`, {
      params
    });
  }
  /**
   * Update a memory
   */
  async updateMemory(agentId, memoryId, params) {
    return this.patch(`/api/memory/${agentId}/memories/${memoryId}`, params);
  }
  /**
   * Clear all agent memories
   */
  async clearAgentMemories(agentId) {
    return this.delete(`/api/memory/${agentId}/memories`);
  }
  /**
   * Clear room memories
   */
  async clearRoomMemories(agentId, roomId) {
    return this.delete(`/api/memory/${agentId}/memories/all/${roomId}`);
  }
  /**
   * List agent's rooms
   */
  async listAgentRooms(agentId) {
    return this.get(`/api/memory/${agentId}/rooms`);
  }
  /**
   * Get room details
   */
  async getRoom(agentId, roomId) {
    return this.get(`/api/memory/${agentId}/rooms/${roomId}`);
  }
  /**
   * Create a room
   */
  async createRoom(agentId, params) {
    return this.post(`/api/memory/${agentId}/rooms`, params);
  }
  /**
   * Create world from server
   */
  async createWorldFromServer(serverId, params) {
    return this.post(`/api/memory/groups/${serverId}`, params);
  }
  /**
   * Delete a world
   */
  async deleteWorld(serverId) {
    return this.delete(`/api/memory/groups/${serverId}`);
  }
  /**
   * Clear world memories
   */
  async clearWorldMemories(serverId) {
    return this.delete(`/api/memory/groups/${serverId}/memories`);
  }
  /**
   * Delete a specific memory
   */
  async deleteMemory(agentId, memoryId) {
    return this.delete(`/api/memory/${agentId}/memories/${memoryId}`);
  }
  /**
   * Get agent internal memories
   */
  async getAgentInternalMemories(agentId, agentPerspectiveRoomId, includeEmbedding) {
    return this.get(
      `/api/memory/${agentId}/rooms/${agentPerspectiveRoomId}/memories`,
      { params: { includeEmbedding } }
    );
  }
  /**
   * Delete agent internal memory
   */
  async deleteAgentInternalMemory(agentId, memoryId) {
    return this.delete(`/api/memory/${agentId}/memories/${memoryId}`);
  }
  /**
   * Delete all agent internal memories
   */
  async deleteAllAgentInternalMemories(agentId, agentPerspectiveRoomId) {
    return this.delete(
      `/api/memory/${agentId}/memories/all/${agentPerspectiveRoomId}`
    );
  }
  /**
   * Update agent internal memory
   */
  async updateAgentInternalMemory(agentId, memoryId, memoryData) {
    return this.patch(`/api/memory/${agentId}/memories/${memoryId}`, memoryData);
  }
  /**
   * Delete group memory (implemented via messaging channel message deletion)
   */
  async deleteGroupMemory(serverId, memoryId) {
    return this.delete(
      `/api/messaging/central-channels/${serverId}/messages/${memoryId}`
    );
  }
  /**
   * Clear group chat (implemented via messaging channel history clearing)
   */
  async clearGroupChat(serverId) {
    return this.delete(
      `/api/messaging/central-channels/${serverId}/messages`
    );
  }
};

// src/services/audio.ts
var AudioService = class extends BaseApiClient {
  /**
   * Make a binary request using BaseApiClient infrastructure
   */
  async requestBinary(method, path, options) {
    let url;
    if (this.baseUrl) {
      url = new URL(`${this.baseUrl}${path}`);
    } else if (typeof window !== "undefined" && window.location) {
      url = new URL(path, window.location.origin);
    } else {
      url = new URL(path, "http://localhost:3000");
    }
    if (options?.params) {
      Object.entries(options.params).forEach(([key, value]) => {
        if (value !== void 0 && value !== null) {
          url.searchParams.append(key, String(value));
        }
      });
    }
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);
    try {
      const headers = {
        ...this.defaultHeaders,
        ...options?.headers
      };
      if (options?.body instanceof FormData) {
        delete headers["Content-Type"];
      }
      const response = await fetch(url.toString(), {
        method,
        headers,
        body: options?.body instanceof FormData ? options.body : options?.body ? JSON.stringify(options.body) : void 0,
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return await response.arrayBuffer();
    } catch (error) {
      clearTimeout(timeoutId);
      if (error instanceof Error) {
        if (error.name === "AbortError") {
          throw new Error("Request timed out");
        }
        throw error;
      }
      throw new Error("An unknown error occurred");
    }
  }
  /**
   * Convert audio input to appropriate FormData value
   */
  processAudioInput(audio) {
    if (audio instanceof Blob) {
      return audio;
    }
    if (typeof audio === "string") {
      if (audio.startsWith("data:")) {
        try {
          const [header, base64Data] = audio.split(",");
          const mimeMatch = header.match(/data:([^;]+)/);
          const mimeType = mimeMatch ? mimeMatch[1] : "audio/wav";
          const binaryString = atob(base64Data);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          return new Blob([bytes], { type: mimeType });
        } catch (error) {
          throw new Error(
            `Invalid base64 data URL: ${error instanceof Error ? error.message : "Unknown error"}`
          );
        }
      }
      if (this.isBase64String(audio)) {
        try {
          const binaryString = atob(audio);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          return new Blob([bytes], { type: "audio/wav" });
        } catch (error) {
          return audio;
        }
      }
      return audio;
    }
    if (this.isBuffer(audio)) {
      return new Blob([audio], { type: "audio/wav" });
    }
    const audioAsAny = audio;
    if (audioAsAny instanceof ArrayBuffer) {
      return new Blob([audioAsAny], { type: "audio/wav" });
    }
    if (audioAsAny && typeof audioAsAny === "object" && "buffer" in audioAsAny && audioAsAny.buffer instanceof ArrayBuffer) {
      return new Blob([audioAsAny.buffer], { type: "audio/wav" });
    }
    throw new Error(
      `Unsupported audio input type: ${typeof audio}. Expected Blob, Buffer, ArrayBuffer, or string.`
    );
  }
  /**
   * Check if a string appears to be base64 encoded
   */
  isBase64String(str) {
    const base64Pattern = /^[A-Za-z0-9+/]*={0,2}$/;
    if (str.length < 4 || str.length % 4 !== 0) {
      return false;
    }
    return base64Pattern.test(str);
  }
  /**
   * Safe check for Buffer type (works in both Node.js and browser environments)
   */
  isBuffer(obj) {
    return obj != null && typeof obj === "object" && typeof obj.constructor === "function" && obj.constructor.name === "Buffer" && typeof obj.readUInt8 === "function";
  }
  /**
   * Handle speech conversation
   */
  async speechConversation(agentId, params) {
    const formData = new FormData();
    const processedAudio = this.processAudioInput(params.audio);
    if (processedAudio instanceof Blob) {
      formData.append("file", processedAudio);
    } else {
      formData.append("file", processedAudio);
    }
    if (params.format) formData.append("format", params.format);
    if (params.language) formData.append("language", params.language);
    if (params.metadata) formData.append("metadata", JSON.stringify(params.metadata));
    return this.request("POST", `/api/audio/${agentId}/speech/conversation`, {
      body: formData
    });
  }
  /**
   * Generate speech from text
   */
  async generateSpeech(agentId, params) {
    const audioBuffer = await this.requestBinary("POST", `/api/audio/${agentId}/speech/generate`, {
      body: params
    });
    const bytes = new Uint8Array(audioBuffer);
    let binary = "";
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    const base64Audio = btoa(binary);
    const format = "mpeg";
    return {
      audio: base64Audio,
      format
    };
  }
  /**
   * Synthesize audio message
   */
  async synthesizeAudioMessage(agentId, params) {
    return this.post(
      `/api/audio/${agentId}/audio-messages/synthesize`,
      params
    );
  }
  /**
   * Transcribe audio to text
   */
  async transcribe(agentId, params) {
    const formData = new FormData();
    const processedAudio = this.processAudioInput(params.audio);
    if (processedAudio instanceof Blob) {
      formData.append("file", processedAudio);
    } else {
      formData.append("file", processedAudio);
    }
    if (params.format) formData.append("format", params.format);
    if (params.language) formData.append("language", params.language);
    return this.request("POST", `/api/audio/${agentId}/transcriptions`, {
      body: formData
    });
  }
  /**
   * Process speech input
   */
  async processSpeech(agentId, audio, metadata) {
    const formData = new FormData();
    const processedAudio = this.processAudioInput(audio);
    if (processedAudio instanceof Blob) {
      formData.append("file", processedAudio);
    } else {
      formData.append("file", processedAudio);
    }
    if (metadata) formData.append("metadata", JSON.stringify(metadata));
    return this.request("POST", `/api/audio/${agentId}/speech`, {
      body: formData
    });
  }
};

// src/services/media.ts
var MediaService = class extends BaseApiClient {
  /**
   * Upload media for an agent
   */
  async uploadAgentMedia(agentId, params) {
    const formData = new FormData();
    formData.append("file", params.file, params.filename);
    if (params.contentType) formData.append("contentType", params.contentType);
    if (params.metadata) formData.append("metadata", JSON.stringify(params.metadata));
    return this.request("POST", `/api/media/agents/${agentId}/upload-media`, {
      body: formData
    });
  }
  /**
   * Upload file to a channel
   */
  async uploadChannelMedia(channelId, file) {
    const formData = new FormData();
    formData.append("file", file);
    return this.request(
      "POST",
      `/api/messaging/central-channels/${channelId}/upload-media`,
      {
        body: formData
      }
    );
  }
};

// src/services/server.ts
var ServerService = class extends BaseApiClient {
  /**
   * Health check
   */
  async checkHealth() {
    return this.get("/api/server/health");
  }
  /**
   * Simple ping
   */
  async ping() {
    return this.get("/api/server/ping");
  }
  /**
   * Hello endpoint
   */
  async hello() {
    return this.get("/api/server/hello");
  }
  /**
   * Get server status
   */
  async getStatus() {
    return this.get("/api/server/status");
  }
  /**
   * Stop the server
   */
  async stopServer() {
    return this.post("/api/server/stop");
  }
  /**
   * Get runtime debug info
   */
  async getDebugInfo() {
    return this.get("/api/server/debug/servers");
  }
  /**
   * Submit logs
   */
  async submitLogs(logs) {
    return this.post("/api/server/logs", { logs });
  }
  /**
   * Clear logs
   */
  async clearLogs() {
    return this.delete("/api/server/logs");
  }
};

// src/services/system.ts
var SystemService = class extends BaseApiClient {
  /**
   * Retrieve the local environment variables from the ElizaOS server.
   *
   * Server route (packages/server/src/api/system):
   *   GET /api/system/env/local  ->  { success: true, data: Record<string,string> }
   */
  async getEnvironment() {
    return this.get("/api/system/env/local");
  }
  /**
   * Update (overwrite or merge) the local .env file on the ElizaOS server.
   *
   * Server route (packages/server/src/api/system):
   *   POST /api/system/env/local  ->  { success: true, message: string }
   *   Body: { content: Record<string,string> }
   *
   * For developer-ergonomics we accept several shapes:
   *   1. { variables: Record<string,string>; merge?: boolean }
   *   2. { content:   Record<string,string> }      (server-native)
   *   3. Record<string,string>                      (shorthand)
   */
  async updateLocalEnvironment(params) {
    if (!params || typeof params !== "object") {
      throw new Error("updateLocalEnvironment requires a configuration object");
    }
    let body;
    if ("variables" in params) {
      body = { content: params.variables };
    } else if ("content" in params) {
      body = { content: params.content };
    } else {
      body = { content: params };
    }
    return this.post("/api/system/env/local", body);
  }
  /**
   * Global logs functionality - implementing via system endpoints
   */
  async getGlobalLogs(params) {
    const response = await fetch(this.buildUrl("/api/server/logs", { params }), {
      method: "GET",
      headers: this.getHeaders()
    });
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    const data = await response.json();
    return {
      logs: data.logs || [],
      count: data.count || 0,
      total: data.total || 0,
      level: data.requestedLevel || data.level || "all",
      levels: data.levels || []
    };
  }
  buildUrl(path, options) {
    const url = new URL(`${this.baseUrl}${path}`);
    if (options?.params) {
      Object.entries(options.params).forEach(([key, value]) => {
        if (value !== void 0 && value !== null) {
          url.searchParams.append(key, String(value));
        }
      });
    }
    return url.toString();
  }
  getHeaders() {
    return {
      ...this.defaultHeaders
    };
  }
  async deleteGlobalLogs() {
    return this.delete("/api/server/logs");
  }
  async deleteLog(logId) {
    throw new Error(
      "Individual log deletion is not supported. Use deleteGlobalLogs() to clear all logs."
    );
  }
};

// src/services/sessions.ts
function toTimestampString(value, paramName) {
  if (!value) return void 0;
  let timestamp;
  if (value instanceof Date) {
    timestamp = value.getTime();
  } else if (typeof value === "string") {
    const date = new Date(value);
    timestamp = date.getTime();
    if (isNaN(timestamp)) {
      console.warn(`Invalid date string for ${paramName}: ${value}`);
      return void 0;
    }
  } else if (typeof value === "number") {
    timestamp = value;
  } else {
    console.warn(`Invalid type for ${paramName}: ${typeof value}`);
    return void 0;
  }
  return timestamp.toString();
}
function validateRequiredParam(value, paramName) {
  if (!value || value.trim() === "") {
    throw new Error(`${paramName} is required and cannot be empty`);
  }
}
var SessionsService = class extends BaseApiClient {
  /**
   * Get health status of the sessions service
   * @returns Health check response
   */
  async checkHealth() {
    return this.get("/api/messaging/sessions/health");
  }
  /**
   * Create a new messaging session
   * @param params Session creation parameters
   * @returns Created session response
   */
  async createSession(params) {
    return this.post("/api/messaging/sessions", params);
  }
  /**
   * Get session details
   * @param sessionId Session ID
   * @returns Session information
   */
  async getSession(sessionId) {
    validateRequiredParam(sessionId, "sessionId");
    return this.get(`/api/messaging/sessions/${sessionId}`);
  }
  /**
   * Send a message in a session
   * @param sessionId Session ID
   * @param params Message parameters
   * @returns Message response
   */
  async sendMessage(sessionId, params) {
    validateRequiredParam(sessionId, "sessionId");
    validateRequiredParam(params?.content, "content");
    return this.post(`/api/messaging/sessions/${sessionId}/messages`, params);
  }
  /**
   * Get messages from a session
   * @param sessionId Session ID
   * @param params Query parameters for pagination and filtering
   * @returns Messages response
   */
  async getMessages(sessionId, params) {
    validateRequiredParam(sessionId, "sessionId");
    const queryParams = {};
    if (params?.limit) {
      queryParams.limit = params.limit.toString();
    }
    const beforeTimestamp = toTimestampString(params?.before, "before");
    if (beforeTimestamp) {
      queryParams.before = beforeTimestamp;
    }
    const afterTimestamp = toTimestampString(params?.after, "after");
    if (afterTimestamp) {
      queryParams.after = afterTimestamp;
    }
    return this.get(`/api/messaging/sessions/${sessionId}/messages`, {
      params: queryParams
    });
  }
  /**
   * Delete a session
   * @param sessionId Session ID
   * @returns Success response
   */
  async deleteSession(sessionId) {
    validateRequiredParam(sessionId, "sessionId");
    return this.delete(`/api/messaging/sessions/${sessionId}`);
  }
  /**
   * List all active sessions (admin endpoint)
   * @returns List of active sessions
   */
  async listSessions() {
    return this.get("/api/messaging/sessions");
  }
};

// src/client.ts
var ElizaClient = class _ElizaClient {
  agents;
  messaging;
  memory;
  audio;
  media;
  server;
  system;
  sessions;
  constructor(config) {
    this.agents = new AgentsService(config);
    this.messaging = new MessagingService(config);
    this.memory = new MemoryService(config);
    this.audio = new AudioService(config);
    this.media = new MediaService(config);
    this.server = new ServerService(config);
    this.system = new SystemService(config);
    this.sessions = new SessionsService(config);
  }
  /**
   * Create a new ElizaClient instance
   */
  static create(config) {
    return new _ElizaClient(config);
  }
};
export {
  AgentsService,
  ApiError,
  AudioService,
  BaseApiClient,
  ElizaClient,
  MediaService,
  MemoryService,
  MessagingService,
  ServerService,
  SessionsService,
  SystemService
};
//# sourceMappingURL=index.js.map