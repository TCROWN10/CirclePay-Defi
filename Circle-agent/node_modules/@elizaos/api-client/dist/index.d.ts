import { UUID, ChannelType } from '@elizaos/core';

interface ApiSuccessResponse<T> {
    success: true;
    data: T;
}
interface ApiErrorResponse {
    success: false;
    error: {
        code: string;
        message: string;
        details?: string;
    };
}
type ApiResponse<T> = ApiSuccessResponse<T> | ApiErrorResponse;
interface RequestConfig {
    headers?: Record<string, string>;
    params?: Record<string, any>;
    timeout?: number;
}
interface PaginationParams {
    page?: number;
    limit?: number;
    offset?: number;
}
interface ApiClientConfig {
    baseUrl: string;
    apiKey?: string;
    timeout?: number;
    headers?: Record<string, string>;
}

declare class ApiError extends Error {
    code: string;
    details?: string;
    status?: number;
    constructor(code: string, message: string, details?: string, status?: number);
}
declare abstract class BaseApiClient {
    protected baseUrl: string;
    protected apiKey?: string;
    protected timeout: number;
    protected defaultHeaders: Record<string, string>;
    constructor(config: ApiClientConfig);
    /**
     * Creates a safe response for no-content scenarios (204 responses)
     * Returns a sensible default based on common API patterns
     */
    private createNoContentResponse;
    protected request<T>(method: string, path: string, options?: {
        body?: any;
        params?: Record<string, any>;
        headers?: Record<string, string>;
        config?: RequestConfig;
    }): Promise<T>;
    protected get<T>(path: string, options?: Omit<Parameters<typeof this.request>[2], 'body'>): Promise<T>;
    protected post<T>(path: string, body?: any, options?: Parameters<typeof this.request>[2]): Promise<T>;
    protected put<T>(path: string, body?: any, options?: Parameters<typeof this.request>[2]): Promise<T>;
    protected patch<T>(path: string, body?: any, options?: Parameters<typeof this.request>[2]): Promise<T>;
    protected delete<T>(path: string, options?: Omit<Parameters<typeof this.request>[2], 'body'>): Promise<T>;
}

interface Agent {
    id: UUID;
    name: string;
    description?: string;
    status: 'active' | 'inactive' | 'stopped';
    enabled?: boolean;
    createdAt: Date;
    updatedAt: Date;
    metadata?: Record<string, any>;
}
interface AgentCreateParams {
    characterPath?: string;
    characterJson?: Record<string, any>;
    agent?: Record<string, any>;
}
interface AgentUpdateParams {
    name?: string;
    description?: string;
    metadata?: Record<string, any>;
}
interface AgentWorld {
    id: UUID;
    name: string;
    description?: string;
    agents?: Agent[];
}
interface AgentWorldSettings {
    worldId: UUID;
    settings: Record<string, any>;
}
interface AgentPanel {
    id: string;
    name: string;
    url: string;
    type: string;
    metadata?: Record<string, any>;
}
interface AgentLog {
    id: UUID;
    agentId: UUID;
    level: 'debug' | 'info' | 'warn' | 'error';
    message: string;
    timestamp: Date;
    metadata?: Record<string, any>;
}
interface AgentLogsParams extends PaginationParams {
    level?: 'debug' | 'info' | 'warn' | 'error';
    from?: Date | string;
    to?: Date | string;
    search?: string;
}

declare class AgentsService extends BaseApiClient {
    /**
     * List all agents with minimal details
     */
    listAgents(): Promise<{
        agents: Agent[];
    }>;
    /**
     * Get specific agent details
     */
    getAgent(agentId: UUID): Promise<Agent>;
    /**
     * Create a new agent
     */
    createAgent(params: AgentCreateParams): Promise<Agent>;
    /**
     * Update an existing agent
     */
    updateAgent(agentId: UUID, params: AgentUpdateParams): Promise<Agent>;
    /**
     * Delete an agent
     */
    deleteAgent(agentId: UUID): Promise<{
        success: boolean;
    }>;
    /**
     * Start an existing agent
     */
    startAgent(agentId: UUID): Promise<{
        status: string;
    }>;
    /**
     * Stop a running agent
     */
    stopAgent(agentId: UUID): Promise<{
        status: string;
    }>;
    /**
     * Get all available worlds
     */
    getWorlds(): Promise<{
        worlds: AgentWorld[];
    }>;
    /**
     * Add agent to a world
     */
    addAgentToWorld(agentId: UUID, worldId: UUID): Promise<{
        success: boolean;
    }>;
    /**
     * Update agent's world settings
     */
    updateAgentWorldSettings(agentId: UUID, worldId: UUID, settings: Record<string, any>): Promise<AgentWorldSettings>;
    /**
     * Get agent's plugin panels
     */
    getAgentPanels(agentId: UUID): Promise<{
        panels: AgentPanel[];
    }>;
    /**
     * Get agent logs
     */
    getAgentLogs(agentId: UUID, params?: AgentLogsParams): Promise<AgentLog[]>;
    /**
     * Delete a specific log entry
     */
    deleteAgentLog(agentId: UUID, logId: UUID): Promise<{
        success: boolean;
    }>;
    /**
     * Get agents associated with a server
     */
    getAgentsForServer(serverId: UUID): Promise<{
        success: boolean;
        data: {
            serverId: UUID;
            agents: UUID[];
        };
    }>;
    addAgentToServer(serverId: UUID, agentId: UUID): Promise<{
        success: boolean;
        data: {
            serverId: UUID;
            agentId: UUID;
            message: string;
        };
    }>;
    removeAgentFromServer(serverId: UUID, agentId: UUID): Promise<{
        success: boolean;
        data: {
            serverId: UUID;
            agentId: UUID;
            message: string;
        };
    }>;
    getServersForAgent(agentId: UUID): Promise<{
        success: boolean;
        data: {
            agentId: UUID;
            servers: UUID[];
        };
    }>;
}

interface MessageServer {
    id: UUID;
    name: string;
    sourceType: string;
    sourceId?: string;
    metadata?: Record<string, any>;
    createdAt: Date;
    updatedAt: Date;
}
interface MessageChannel {
    id: UUID;
    messageServerId: UUID;
    name: string;
    type: ChannelType;
    sourceType?: string;
    sourceId?: string;
    topic?: string;
    metadata?: Record<string, any>;
    createdAt: Date;
    updatedAt: Date;
}
interface Message {
    id: UUID;
    channelId: UUID;
    authorId: UUID;
    content: string;
    rawMessage?: any;
    inReplyToRootMessageId?: UUID;
    sourceType?: string;
    sourceId?: string;
    createdAt: Date;
    updatedAt: Date;
    metadata?: Record<string, any>;
}
interface MessageSubmitParams {
    agentId: UUID;
    channelId: UUID;
    content: string;
    inReplyToMessageId?: UUID;
    metadata?: Record<string, any>;
}
interface MessageCompleteParams {
    messageId: UUID;
    status: 'completed' | 'failed';
    error?: string;
}
interface ExternalMessageParams {
    platform: string;
    channelId: string;
    messages: Array<{
        id: string;
        authorId: string;
        content: string;
        timestamp: number;
        metadata?: Record<string, any>;
    }>;
}
interface ChannelCreateParams {
    name: string;
    type: ChannelType;
    serverId?: UUID;
    metadata?: Record<string, any>;
}
interface GroupChannelCreateParams {
    name: string;
    participantIds: UUID[];
    metadata?: Record<string, any>;
}
interface DmChannelParams {
    participantIds: [UUID, UUID];
}
interface ChannelParticipant {
    id: UUID;
    channelId: UUID;
    userId: UUID;
    role?: string;
    joinedAt: Date;
}
interface MessageSearchParams extends PaginationParams {
    query?: string;
    channelId?: UUID;
    authorId?: UUID;
    from?: Date | string;
    to?: Date | string;
}
interface ServerCreateParams {
    name: string;
    sourceType: string;
    sourceId?: string;
    metadata?: Record<string, any>;
}
interface ServerSyncParams {
    channels: Array<{
        name: string;
        type: ChannelType;
        sourceId: string;
    }>;
}
interface ChannelUpdateParams {
    name?: string;
    participantCentralUserIds?: UUID[];
    metadata?: Record<string, any>;
}

declare class MessagingService extends BaseApiClient {
    /**
     * Submit agent replies or system messages
     */
    submitMessage(params: MessageSubmitParams): Promise<Message>;
    /**
     * Notify message completion
     */
    completeMessage(params: MessageCompleteParams): Promise<{
        success: boolean;
    }>;
    /**
     * Ingest messages from external platforms
     */
    ingestExternalMessages(params: ExternalMessageParams): Promise<{
        processed: number;
    }>;
    /**
     * Create a new channel
     */
    createChannel(params: ChannelCreateParams): Promise<MessageChannel>;
    /**
     * Create a group channel
     */
    createGroupChannel(params: GroupChannelCreateParams): Promise<MessageChannel>;
    /**
     * Find or create a DM channel
     */
    getOrCreateDmChannel(params: DmChannelParams): Promise<MessageChannel>;
    /**
     * Get channel details
     */
    getChannelDetails(channelId: UUID): Promise<MessageChannel>;
    /**
     * Get channel participants
     */
    getChannelParticipants(channelId: UUID): Promise<{
        participants: ChannelParticipant[];
    }>;
    /**
     * Add agent to channel
     */
    addAgentToChannel(channelId: UUID, agentId: UUID): Promise<{
        success: boolean;
    }>;
    /**
     * Remove agent from channel
     */
    removeAgentFromChannel(channelId: UUID, agentId: UUID): Promise<{
        success: boolean;
    }>;
    /**
     * Delete a channel
     */
    deleteChannel(channelId: UUID): Promise<{
        success: boolean;
    }>;
    /**
     * Clear channel history
     */
    clearChannelHistory(channelId: UUID): Promise<{
        deleted: number;
    }>;
    /**
     * Post a new message to a channel
     */
    postMessage(channelId: UUID, content: string, metadata?: Record<string, any>): Promise<Message>;
    /**
     * Get channel messages
     */
    getChannelMessages(channelId: UUID, params?: PaginationParams & {
        before?: Date | string;
        after?: Date | string;
    }): Promise<{
        messages: Message[];
    }>;
    /**
     * Get a specific message
     */
    getMessage(messageId: UUID): Promise<Message>;
    /**
     * Delete a message from a channel
     */
    deleteMessage(channelId: UUID, messageId: UUID): Promise<{
        success: boolean;
    }>;
    /**
     * Update a message
     */
    updateMessage(messageId: UUID, content: string): Promise<Message>;
    /**
     * Search messages
     */
    searchMessages(params: MessageSearchParams): Promise<{
        messages: Message[];
    }>;
    /**
     * List all message servers
     */
    listServers(): Promise<{
        servers: MessageServer[];
    }>;
    /**
     * Get server channels
     */
    getServerChannels(serverId: UUID): Promise<{
        channels: MessageChannel[];
    }>;
    /**
     * Create a new server
     */
    createServer(params: ServerCreateParams): Promise<MessageServer>;
    /**
     * Sync server channels
     */
    syncServerChannels(serverId: UUID, params: ServerSyncParams): Promise<{
        synced: number;
    }>;
    /**
     * Delete a server
     */
    deleteServer(serverId: UUID): Promise<{
        success: boolean;
    }>;
    /**
     * Update a channel
     */
    updateChannel(channelId: UUID, params: ChannelUpdateParams): Promise<{
        success: boolean;
        data: MessageChannel;
    }>;
    /**
     * Generate channel title
     */
    generateChannelTitle(channelId: UUID, agentId: UUID): Promise<{
        title: string;
    }>;
    /**
     * Add user to channel participants (implemented via updateChannel)
     */
    addUserToChannel(channelId: UUID, userId: UUID): Promise<{
        success: boolean;
        data: MessageChannel;
    }>;
    /**
     * Add multiple users to channel participants (implemented via updateChannel)
     */
    addUsersToChannel(channelId: UUID, userIds: UUID[]): Promise<{
        success: boolean;
        data: MessageChannel;
    }>;
    /**
     * Remove user from channel participants (implemented via updateChannel)
     */
    removeUserFromChannel(channelId: UUID, userId: UUID): Promise<{
        success: boolean;
        data: MessageChannel;
    }>;
}

interface Memory {
    id: UUID;
    agentId: UUID;
    roomId?: UUID;
    type: string;
    content: any;
    embedding?: number[];
    createdAt: Date;
    updatedAt: Date;
    metadata?: Record<string, any>;
}
interface Room {
    id: UUID;
    agentId: UUID;
    name: string;
    type?: string;
    createdAt: Date;
    updatedAt: Date;
    metadata?: Record<string, any>;
}
interface MemoryParams extends PaginationParams {
    type?: string;
    search?: string;
    from?: Date | string;
    to?: Date | string;
}
interface MemoryUpdateParams {
    content?: any;
    metadata?: Record<string, any>;
}
interface RoomCreateParams {
    name: string;
    type?: string;
    metadata?: Record<string, any>;
}
interface WorldCreateParams {
    serverId: UUID;
    name: string;
    description?: string;
}

declare class MemoryService extends BaseApiClient {
    /**
     * Get agent memories
     */
    getAgentMemories(agentId: UUID, params?: MemoryParams): Promise<{
        memories: Memory[];
    }>;
    /**
     * Get room-specific memories
     */
    getRoomMemories(agentId: UUID, roomId: UUID, params?: MemoryParams): Promise<{
        memories: Memory[];
    }>;
    /**
     * Update a memory
     */
    updateMemory(agentId: UUID, memoryId: UUID, params: MemoryUpdateParams): Promise<Memory>;
    /**
     * Clear all agent memories
     */
    clearAgentMemories(agentId: UUID): Promise<{
        deleted: number;
    }>;
    /**
     * Clear room memories
     */
    clearRoomMemories(agentId: UUID, roomId: UUID): Promise<{
        deleted: number;
    }>;
    /**
     * List agent's rooms
     */
    listAgentRooms(agentId: UUID): Promise<{
        rooms: Room[];
    }>;
    /**
     * Get room details
     */
    getRoom(agentId: UUID, roomId: UUID): Promise<Room>;
    /**
     * Create a room
     */
    createRoom(agentId: UUID, params: RoomCreateParams): Promise<Room>;
    /**
     * Create world from server
     */
    createWorldFromServer(serverId: UUID, params: WorldCreateParams): Promise<{
        worldId: UUID;
    }>;
    /**
     * Delete a world
     */
    deleteWorld(serverId: UUID): Promise<{
        success: boolean;
    }>;
    /**
     * Clear world memories
     */
    clearWorldMemories(serverId: UUID): Promise<{
        deleted: number;
    }>;
    /**
     * Delete a specific memory
     */
    deleteMemory(agentId: UUID, memoryId: UUID): Promise<{
        success: boolean;
    }>;
    /**
     * Get agent internal memories
     */
    getAgentInternalMemories(agentId: UUID, agentPerspectiveRoomId: UUID, includeEmbedding?: boolean): Promise<{
        success: boolean;
        data: any[];
    }>;
    /**
     * Delete agent internal memory
     */
    deleteAgentInternalMemory(agentId: UUID, memoryId: UUID): Promise<{
        success: boolean;
    }>;
    /**
     * Delete all agent internal memories
     */
    deleteAllAgentInternalMemories(agentId: UUID, agentPerspectiveRoomId: UUID): Promise<{
        success: boolean;
    }>;
    /**
     * Update agent internal memory
     */
    updateAgentInternalMemory(agentId: UUID, memoryId: UUID, memoryData: any): Promise<any>;
    /**
     * Delete group memory (implemented via messaging channel message deletion)
     */
    deleteGroupMemory(serverId: UUID, memoryId: UUID): Promise<{
        success: boolean;
    }>;
    /**
     * Clear group chat (implemented via messaging channel history clearing)
     */
    clearGroupChat(serverId: UUID): Promise<{
        success: boolean;
    }>;
}

interface SpeechConversationParams {
    audio: Blob | Buffer | string;
    format?: 'mp3' | 'wav' | 'ogg' | 'webm';
    language?: string;
    metadata?: Record<string, any>;
}
interface SpeechGenerateParams {
    text: string;
    voice?: string;
    language?: string;
    speed?: number;
    pitch?: number;
}
interface AudioSynthesizeParams {
    messageId: UUID;
    voice?: string;
    format?: 'mp3' | 'wav' | 'ogg';
}
interface TranscribeParams {
    audio: Blob | Buffer | string;
    format?: 'mp3' | 'wav' | 'ogg' | 'webm';
    language?: string;
}
interface SpeechResponse {
    text?: string;
    audio?: string;
    duration?: number;
    metadata?: Record<string, any>;
}
interface TranscriptionResponse {
    text: string;
    language?: string;
    confidence?: number;
    words?: Array<{
        word: string;
        start: number;
        end: number;
        confidence?: number;
    }>;
}

declare class AudioService extends BaseApiClient {
    /**
     * Make a binary request using BaseApiClient infrastructure
     */
    private requestBinary;
    /**
     * Convert audio input to appropriate FormData value
     */
    private processAudioInput;
    /**
     * Check if a string appears to be base64 encoded
     */
    private isBase64String;
    /**
     * Safe check for Buffer type (works in both Node.js and browser environments)
     */
    private isBuffer;
    /**
     * Handle speech conversation
     */
    speechConversation(agentId: UUID, params: SpeechConversationParams): Promise<SpeechResponse>;
    /**
     * Generate speech from text
     */
    generateSpeech(agentId: UUID, params: SpeechGenerateParams): Promise<{
        audio: string;
        format: string;
    }>;
    /**
     * Synthesize audio message
     */
    synthesizeAudioMessage(agentId: UUID, params: AudioSynthesizeParams): Promise<{
        audio: string;
        format: string;
    }>;
    /**
     * Transcribe audio to text
     */
    transcribe(agentId: UUID, params: TranscribeParams): Promise<TranscriptionResponse>;
    /**
     * Process speech input
     */
    processSpeech(agentId: UUID, audio: Blob | Buffer | string, metadata?: Record<string, any>): Promise<SpeechResponse>;
}

interface MediaUploadParams {
    file: File | Blob;
    filename?: string;
    contentType?: string;
    metadata?: Record<string, any>;
}
interface MediaUploadResponse {
    url: string;
    type: string;
    filename: string;
    originalName: string;
    size: number;
}
interface ChannelUploadResponse {
    url: string;
    type: string;
    filename: string;
    originalName: string;
    size: number;
}

declare class MediaService extends BaseApiClient {
    /**
     * Upload media for an agent
     */
    uploadAgentMedia(agentId: UUID, params: MediaUploadParams): Promise<MediaUploadResponse>;
    /**
     * Upload file to a channel
     */
    uploadChannelMedia(channelId: UUID, file: File): Promise<ChannelUploadResponse>;
}

interface ServerHealth {
    status: 'healthy' | 'degraded' | 'unhealthy';
    uptime: number;
    timestamp: Date;
    version?: string;
    checks?: Record<string, {
        status: 'pass' | 'fail';
        message?: string;
    }>;
}
interface ServerStatus {
    agents: {
        total: number;
        active: number;
        inactive: number;
    };
    memory: {
        used: number;
        total: number;
        percentage: number;
    };
    uptime: number;
    version: string;
}
interface ServerDebugInfo {
    runtime: {
        agents: Array<{
            id: UUID;
            name: string;
            status: string;
        }>;
        connections: number;
        memory: any;
    };
    environment: Record<string, string>;
}
interface LogSubmitParams {
    level: 'debug' | 'info' | 'warn' | 'error';
    message: string;
    source?: string;
    metadata?: Record<string, any>;
}

declare class ServerService extends BaseApiClient {
    /**
     * Health check
     */
    checkHealth(): Promise<ServerHealth>;
    /**
     * Simple ping
     */
    ping(): Promise<{
        pong: boolean;
    }>;
    /**
     * Hello endpoint
     */
    hello(): Promise<{
        message: string;
    }>;
    /**
     * Get server status
     */
    getStatus(): Promise<ServerStatus>;
    /**
     * Stop the server
     */
    stopServer(): Promise<{
        success: boolean;
    }>;
    /**
     * Get runtime debug info
     */
    getDebugInfo(): Promise<ServerDebugInfo>;
    /**
     * Submit logs
     */
    submitLogs(logs: LogSubmitParams[]): Promise<{
        received: number;
    }>;
    /**
     * Clear logs
     */
    clearLogs(): Promise<{
        cleared: number;
    }>;
}

interface SystemEnvironment {
    nodeVersion: string;
    platform: string;
    environment: 'development' | 'production' | 'test';
    features: {
        authentication: boolean;
        tee: boolean;
        plugins: string[];
    };
    configuration: Record<string, any>;
}
interface LocalEnvironmentUpdateParams {
    variables: Record<string, string>;
    merge?: boolean;
}

declare class SystemService extends BaseApiClient {
    /**
     * Retrieve the local environment variables from the ElizaOS server.
     *
     * Server route (packages/server/src/api/system):
     *   GET /api/system/env/local  ->  { success: true, data: Record<string,string> }
     */
    getEnvironment(): Promise<Record<string, string>>;
    /**
     * Update (overwrite or merge) the local .env file on the ElizaOS server.
     *
     * Server route (packages/server/src/api/system):
     *   POST /api/system/env/local  ->  { success: true, message: string }
     *   Body: { content: Record<string,string> }
     *
     * For developer-ergonomics we accept several shapes:
     *   1. { variables: Record<string,string>; merge?: boolean }
     *   2. { content:   Record<string,string> }      (server-native)
     *   3. Record<string,string>                      (shorthand)
     */
    updateLocalEnvironment(params: LocalEnvironmentUpdateParams | {
        content: Record<string, string>;
    } | Record<string, string>): Promise<{
        success: boolean;
        message: string;
    }>;
    /**
     * Global logs functionality - implementing via system endpoints
     */
    getGlobalLogs(params?: {
        level?: string;
        agentName?: string;
        agentId?: string;
    }): Promise<{
        logs: Array<{
            level: number;
            time: number;
            msg: string;
            [key: string]: string | number | boolean | null | undefined;
        }>;
        count: number;
        total: number;
        level: string;
        levels: string[];
    }>;
    private buildUrl;
    private getHeaders;
    deleteGlobalLogs(): Promise<{
        status: string;
        message: string;
    }>;
    deleteLog(logId: string): Promise<void>;
}

/**
 * Attachment type for messages
 */
interface MessageAttachment {
    type: 'image' | 'file' | 'audio' | 'video' | 'document';
    url: string;
    name?: string;
    size?: number;
    mimeType?: string;
}
/**
 * Message metadata type
 */
interface MessageMetadata {
    source?: string;
    priority?: 'low' | 'normal' | 'high';
    tags?: string[];
    context?: Record<string, string | number | boolean>;
    thought?: string;
    actions?: string[];
    [key: string]: string | number | boolean | string[] | Record<string, string | number | boolean> | undefined;
}
/**
 * Metadata associated with a session
 */
interface SessionMetadata {
    platform?: string;
    username?: string;
    discriminator?: string;
    avatar?: string;
    [key: string]: string | number | boolean | undefined;
}
/**
 * Represents a messaging session between a user and an agent
 */
interface Session {
    id: string;
    agentId: UUID;
    channelId: UUID;
    userId: UUID;
    metadata: SessionMetadata;
    createdAt: Date;
    lastActivity: Date;
}
/**
 * Request parameters for creating a session
 */
interface CreateSessionParams {
    agentId: string;
    userId: string;
    metadata?: SessionMetadata;
}
/**
 * Response for session creation
 */
interface CreateSessionResponse {
    sessionId: string;
    agentId: UUID;
    userId: UUID;
    createdAt: Date;
    metadata: SessionMetadata;
}
/**
 * Request parameters for sending a message
 */
interface SendMessageParams {
    content: string;
    attachments?: MessageAttachment[];
    metadata?: MessageMetadata;
}
/**
 * Query parameters for retrieving messages
 */
interface GetMessagesParams extends PaginationParams {
    before?: Date | string | number;
    after?: Date | string | number;
}
/**
 * Simplified message format for API responses
 */
interface SimplifiedMessage {
    id: string;
    content: string;
    authorId: string;
    isAgent: boolean;
    createdAt: Date;
    metadata: MessageMetadata;
}
/**
 * Response for message retrieval
 */
interface GetMessagesResponse {
    messages: SimplifiedMessage[];
    hasMore: boolean;
}
/**
 * Session info response
 */
interface SessionInfoResponse {
    sessionId: string;
    agentId: UUID;
    userId: UUID;
    createdAt: Date;
    lastActivity: Date;
    metadata: SessionMetadata;
}
/**
 * Health check response
 */
interface SessionsHealthResponse {
    status: 'healthy' | 'unhealthy';
    activeSessions: number;
    timestamp: string;
}
/**
 * List sessions response
 */
interface ListSessionsResponse {
    sessions: SessionInfoResponse[];
    total: number;
}
/**
 * Message response when sending a message
 */
interface MessageResponse {
    id: string;
    content: string;
    authorId: string;
    createdAt: Date;
    metadata?: MessageMetadata;
}

/**
 * Service for managing messaging sessions between users and agents
 */
declare class SessionsService extends BaseApiClient {
    /**
     * Get health status of the sessions service
     * @returns Health check response
     */
    checkHealth(): Promise<SessionsHealthResponse>;
    /**
     * Create a new messaging session
     * @param params Session creation parameters
     * @returns Created session response
     */
    createSession(params: CreateSessionParams): Promise<CreateSessionResponse>;
    /**
     * Get session details
     * @param sessionId Session ID
     * @returns Session information
     */
    getSession(sessionId: string): Promise<SessionInfoResponse>;
    /**
     * Send a message in a session
     * @param sessionId Session ID
     * @param params Message parameters
     * @returns Message response
     */
    sendMessage(sessionId: string, params: SendMessageParams): Promise<MessageResponse>;
    /**
     * Get messages from a session
     * @param sessionId Session ID
     * @param params Query parameters for pagination and filtering
     * @returns Messages response
     */
    getMessages(sessionId: string, params?: GetMessagesParams): Promise<GetMessagesResponse>;
    /**
     * Delete a session
     * @param sessionId Session ID
     * @returns Success response
     */
    deleteSession(sessionId: string): Promise<{
        success: boolean;
    }>;
    /**
     * List all active sessions (admin endpoint)
     * @returns List of active sessions
     */
    listSessions(): Promise<ListSessionsResponse>;
}

declare class ElizaClient {
    readonly agents: AgentsService;
    readonly messaging: MessagingService;
    readonly memory: MemoryService;
    readonly audio: AudioService;
    readonly media: MediaService;
    readonly server: ServerService;
    readonly system: SystemService;
    readonly sessions: SessionsService;
    constructor(config: ApiClientConfig);
    /**
     * Create a new ElizaClient instance
     */
    static create(config: ApiClientConfig): ElizaClient;
}

export { type Agent, type AgentCreateParams, type AgentLog, type AgentLogsParams, type AgentPanel, type AgentUpdateParams, type AgentWorld, type AgentWorldSettings, AgentsService, type ApiClientConfig, ApiError, type ApiErrorResponse, type ApiResponse, type ApiSuccessResponse, AudioService, type AudioSynthesizeParams, BaseApiClient, type ChannelCreateParams, type ChannelParticipant, type ChannelUpdateParams, type ChannelUploadResponse, type CreateSessionParams, type CreateSessionResponse, type DmChannelParams, ElizaClient, type ExternalMessageParams, type GetMessagesParams, type GetMessagesResponse, type GroupChannelCreateParams, type ListSessionsResponse, type LocalEnvironmentUpdateParams, type LogSubmitParams, MediaService, type MediaUploadParams, type MediaUploadResponse, type Memory, type MemoryParams, MemoryService, type MemoryUpdateParams, type Message, type MessageAttachment, type MessageChannel, type MessageCompleteParams, type MessageMetadata, type MessageResponse, type MessageSearchParams, type MessageServer, type MessageSubmitParams, MessagingService, type PaginationParams, type RequestConfig, type Room, type RoomCreateParams, type SendMessageParams, type ServerCreateParams, type ServerDebugInfo, type ServerHealth, ServerService, type ServerStatus, type ServerSyncParams, type Session, type SessionInfoResponse, type SessionMetadata, type SessionsHealthResponse, SessionsService, type SimplifiedMessage, type SpeechConversationParams, type SpeechGenerateParams, type SpeechResponse, type SystemEnvironment, SystemService, type TranscribeParams, type TranscriptionResponse, type WorldCreateParams };
