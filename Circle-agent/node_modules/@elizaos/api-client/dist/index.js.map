{"version":3,"sources":["../src/lib/base-client.ts","../src/services/agents.ts","../src/services/messaging.ts","../src/services/memory.ts","../src/services/audio.ts","../src/services/media.ts","../src/services/server.ts","../src/services/system.ts","../src/services/sessions.ts","../src/client.ts"],"sourcesContent":["import { ApiResponse, ApiClientConfig, RequestConfig } from '../types/base';\n\ndeclare const window: any;\n\nexport class ApiError extends Error {\n  constructor(\n    public code: string,\n    message: string,\n    public details?: string,\n    public status?: number\n  ) {\n    super(message);\n    this.name = 'ApiError';\n  }\n}\n\nexport abstract class BaseApiClient {\n  protected baseUrl: string;\n  protected apiKey?: string;\n  protected timeout: number;\n  protected defaultHeaders: Record<string, string>;\n\n  constructor(config: ApiClientConfig) {\n    this.baseUrl = config.baseUrl.replace(/\\/$/, ''); // Remove trailing slash\n    this.apiKey = config.apiKey;\n    this.timeout = config.timeout || 30000; // 30 seconds default\n    this.defaultHeaders = {\n      'Content-Type': 'application/json',\n      ...config.headers,\n    };\n\n    if (this.apiKey) {\n      // Server expects X-API-KEY header; keep backward compatibility\n      this.defaultHeaders['X-API-KEY'] = this.apiKey;\n    }\n  }\n\n  /**\n   * Creates a safe response for no-content scenarios (204 responses)\n   * Returns a sensible default based on common API patterns\n   */\n  private createNoContentResponse<T>(): T {\n    // For most delete/update operations, return a success indicator\n    // This handles the common case of { success: boolean } return types\n    return { success: true } as T;\n  }\n\n  protected async request<T>(\n    method: string,\n    path: string,\n    options?: {\n      body?: any;\n      params?: Record<string, any>;\n      headers?: Record<string, string>;\n      config?: RequestConfig;\n    }\n  ): Promise<T> {\n    // Handle empty baseUrl for relative URLs\n    let url: URL;\n    if (this.baseUrl) {\n      url = new URL(`${this.baseUrl}${path}`);\n    } else if (typeof window !== 'undefined' && window.location) {\n      url = new URL(path, window.location.origin);\n    } else {\n      // Fallback for non-browser environments\n      url = new URL(path, 'http://localhost:3000');\n    }\n\n    // Add query parameters\n    if (options?.params) {\n      Object.entries(options.params).forEach(([key, value]) => {\n        if (value !== undefined && value !== null) {\n          url.searchParams.append(key, String(value));\n        }\n      });\n    }\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n    try {\n      const headers = {\n        ...this.defaultHeaders,\n        ...options?.config?.headers,\n        ...options?.headers,\n      };\n\n      // Remove Content-Type header if body is FormData\n      if (options?.body instanceof FormData) {\n        delete headers['Content-Type'];\n      }\n\n      const response = await fetch(url.toString(), {\n        method,\n        headers,\n        body:\n          options?.body instanceof FormData\n            ? options.body\n            : options?.body\n              ? JSON.stringify(options.body)\n              : undefined,\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      // Handle empty responses (204 No Content)\n      if (response.status === 204 || response.headers.get('content-length') === '0') {\n        // For 204 No Content, create a synthetic success response\n        return this.createNoContentResponse<T>();\n      }\n\n      // Parse JSON response\n      let jsonData: any;\n      try {\n        jsonData = await response.json();\n      } catch (error) {\n        // If JSON parsing fails, treat as success for 2xx responses\n        if (response.ok) {\n          return this.createNoContentResponse<T>();\n        } else {\n          throw new ApiError(\n            'PARSE_ERROR',\n            'Failed to parse response as JSON',\n            undefined,\n            response.status\n          );\n        }\n      }\n\n      // Handle error responses\n      if (!response.ok) {\n        // Try to extract error information from response\n        const error = jsonData?.error || {\n          code: 'HTTP_ERROR',\n          message: `HTTP ${response.status}: ${response.statusText}`,\n        };\n        throw new ApiError(error.code, error.message, error.details, response.status);\n      }\n\n      // Handle successful responses\n      // Check if response is wrapped in { success: true, data: ... } format\n      if (jsonData && typeof jsonData === 'object' && 'success' in jsonData) {\n        const apiResponse = jsonData as ApiResponse<T>;\n        if (!apiResponse.success) {\n          const error =\n            'error' in apiResponse\n              ? apiResponse.error\n              : {\n                  code: 'UNKNOWN_ERROR',\n                  message: 'An unknown error occurred',\n                };\n          throw new ApiError(error.code, error.message, error.details, response.status);\n        }\n        return apiResponse.data;\n      } else {\n        // Response is not wrapped - return the data directly\n        // This handles server endpoints like /health, /ping, /status\n        return jsonData as T;\n      }\n    } catch (error) {\n      clearTimeout(timeoutId);\n\n      if (error instanceof ApiError) {\n        throw error;\n      }\n\n      if (error instanceof Error) {\n        if (error.name === 'AbortError') {\n          throw new ApiError('TIMEOUT', 'Request timed out');\n        }\n        throw new ApiError('NETWORK_ERROR', error.message);\n      }\n\n      throw new ApiError('UNKNOWN_ERROR', 'An unknown error occurred');\n    }\n  }\n\n  protected async get<T>(\n    path: string,\n    options?: Omit<Parameters<typeof this.request>[2], 'body'>\n  ): Promise<T> {\n    return this.request<T>('GET', path, options);\n  }\n\n  protected async post<T>(\n    path: string,\n    body?: any,\n    options?: Parameters<typeof this.request>[2]\n  ): Promise<T> {\n    return this.request<T>('POST', path, { ...options, body });\n  }\n\n  protected async put<T>(\n    path: string,\n    body?: any,\n    options?: Parameters<typeof this.request>[2]\n  ): Promise<T> {\n    return this.request<T>('PUT', path, { ...options, body });\n  }\n\n  protected async patch<T>(\n    path: string,\n    body?: any,\n    options?: Parameters<typeof this.request>[2]\n  ): Promise<T> {\n    return this.request<T>('PATCH', path, { ...options, body });\n  }\n\n  protected async delete<T>(\n    path: string,\n    options?: Omit<Parameters<typeof this.request>[2], 'body'>\n  ): Promise<T> {\n    return this.request<T>('DELETE', path, options);\n  }\n}\n","import { UUID } from '@elizaos/core';\nimport { BaseApiClient } from '../lib/base-client';\nimport {\n  Agent,\n  AgentCreateParams,\n  AgentLog,\n  AgentLogsParams,\n  AgentPanel,\n  AgentUpdateParams,\n  AgentWorld,\n  AgentWorldSettings,\n} from '../types/agents';\n\nexport class AgentsService extends BaseApiClient {\n  /**\n   * List all agents with minimal details\n   */\n  async listAgents(): Promise<{ agents: Agent[] }> {\n    return this.get<{ agents: Agent[] }>('/api/agents');\n  }\n\n  /**\n   * Get specific agent details\n   */\n  async getAgent(agentId: UUID): Promise<Agent> {\n    return this.get<Agent>(`/api/agents/${agentId}`);\n  }\n\n  /**\n   * Create a new agent\n   */\n  async createAgent(params: AgentCreateParams): Promise<Agent> {\n    return this.post<Agent>('/api/agents', params);\n  }\n\n  /**\n   * Update an existing agent\n   */\n  async updateAgent(agentId: UUID, params: AgentUpdateParams): Promise<Agent> {\n    return this.patch<Agent>(`/api/agents/${agentId}`, params);\n  }\n\n  /**\n   * Delete an agent\n   */\n  async deleteAgent(agentId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(`/api/agents/${agentId}`);\n  }\n\n  /**\n   * Start an existing agent\n   */\n  async startAgent(agentId: UUID): Promise<{ status: string }> {\n    return this.post<{ status: string }>(`/api/agents/${agentId}/start`);\n  }\n\n  /**\n   * Stop a running agent\n   */\n  async stopAgent(agentId: UUID): Promise<{ status: string }> {\n    return this.post<{ status: string }>(`/api/agents/${agentId}/stop`);\n  }\n\n  /**\n   * Get all available worlds\n   */\n  async getWorlds(): Promise<{ worlds: AgentWorld[] }> {\n    return this.get<{ worlds: AgentWorld[] }>('/api/agents/worlds');\n  }\n\n  /**\n   * Add agent to a world\n   */\n  async addAgentToWorld(agentId: UUID, worldId: UUID): Promise<{ success: boolean }> {\n    return this.post<{ success: boolean }>(`/api/agents/${agentId}/worlds`, { worldId });\n  }\n\n  /**\n   * Update agent's world settings\n   */\n  async updateAgentWorldSettings(\n    agentId: UUID,\n    worldId: UUID,\n    settings: Record<string, any>\n  ): Promise<AgentWorldSettings> {\n    return this.patch<AgentWorldSettings>(`/api/agents/${agentId}/worlds/${worldId}`, { settings });\n  }\n\n  /**\n   * Get agent's plugin panels\n   */\n  async getAgentPanels(agentId: UUID): Promise<{ panels: AgentPanel[] }> {\n    const response = await this.get<Array<{ name: string; path: string }>>(\n      `/api/agents/${agentId}/panels`\n    );\n\n    const panels: AgentPanel[] = (Array.isArray(response) ? response : []).map((panel, index) => ({\n      id: `${panel.name}-${index}`, // Generate an ID since server doesn't send one\n      name: panel.name,\n      url: panel.path,\n      type: 'plugin',\n    }));\n\n    return { panels };\n  }\n\n  /**\n   * Get agent logs\n   */\n  async getAgentLogs(agentId: UUID, params?: AgentLogsParams): Promise<AgentLog[]> {\n    return this.get<AgentLog[]>(`/api/agents/${agentId}/logs`, { params });\n  }\n\n  /**\n   * Delete a specific log entry\n   */\n  async deleteAgentLog(agentId: UUID, logId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(`/api/agents/${agentId}/logs/${logId}`);\n  }\n\n  /**\n   * Get agents associated with a server\n   */\n  async getAgentsForServer(\n    serverId: UUID\n  ): Promise<{ success: boolean; data: { serverId: UUID; agents: UUID[] } }> {\n    return this.get<{ success: boolean; data: { serverId: UUID; agents: UUID[] } }>(\n      `/api/messaging/servers/${serverId}/agents`\n    );\n  }\n\n  async addAgentToServer(\n    serverId: UUID,\n    agentId: UUID\n  ): Promise<{ success: boolean; data: { serverId: UUID; agentId: UUID; message: string } }> {\n    return this.post<{\n      success: boolean;\n      data: { serverId: UUID; agentId: UUID; message: string };\n    }>(`/api/messaging/servers/${serverId}/agents`, { agentId });\n  }\n\n  async removeAgentFromServer(\n    serverId: UUID,\n    agentId: UUID\n  ): Promise<{ success: boolean; data: { serverId: UUID; agentId: UUID; message: string } }> {\n    return this.delete<{\n      success: boolean;\n      data: { serverId: UUID; agentId: UUID; message: string };\n    }>(`/api/messaging/servers/${serverId}/agents/${agentId}`);\n  }\n\n  async getServersForAgent(\n    agentId: UUID\n  ): Promise<{ success: boolean; data: { agentId: UUID; servers: UUID[] } }> {\n    return this.get<{ success: boolean; data: { agentId: UUID; servers: UUID[] } }>(\n      `/api/messaging/agents/${agentId}/servers`\n    );\n  }\n}\n","import { UUID } from '@elizaos/core';\nimport { BaseApiClient } from '../lib/base-client';\nimport {\n  Message,\n  MessageServer,\n  MessageChannel,\n  MessageSubmitParams,\n  MessageCompleteParams,\n  ExternalMessageParams,\n  ChannelCreateParams,\n  GroupChannelCreateParams,\n  DmChannelParams,\n  ChannelParticipant,\n  MessageSearchParams,\n  ServerCreateParams,\n  ServerSyncParams,\n  ChannelUpdateParams,\n} from '../types/messaging';\nimport { PaginationParams } from '../types/base';\n\nexport class MessagingService extends BaseApiClient {\n  /**\n   * Submit agent replies or system messages\n   */\n  async submitMessage(params: MessageSubmitParams): Promise<Message> {\n    return this.post<Message>('/api/messaging/submit', params);\n  }\n\n  /**\n   * Notify message completion\n   */\n  async completeMessage(params: MessageCompleteParams): Promise<{ success: boolean }> {\n    return this.post<{ success: boolean }>('/api/messaging/complete', params);\n  }\n\n  /**\n   * Ingest messages from external platforms\n   */\n  async ingestExternalMessages(params: ExternalMessageParams): Promise<{ processed: number }> {\n    return this.post<{ processed: number }>('/api/messaging/ingest-external', params);\n  }\n\n  /**\n   * Create a new channel\n   */\n  async createChannel(params: ChannelCreateParams): Promise<MessageChannel> {\n    return this.post<MessageChannel>('/api/messaging/central-channels', params);\n  }\n\n  /**\n   * Create a group channel\n   */\n  async createGroupChannel(params: GroupChannelCreateParams): Promise<MessageChannel> {\n    return this.post<MessageChannel>('/api/messaging/central-channels', params);\n  }\n\n  /**\n   * Find or create a DM channel\n   */\n  async getOrCreateDmChannel(params: DmChannelParams): Promise<MessageChannel> {\n    return this.get<MessageChannel>('/api/messaging/dm-channel', { params });\n  }\n\n  /**\n   * Get channel details\n   */\n  async getChannelDetails(channelId: UUID): Promise<MessageChannel> {\n    return this.get<MessageChannel>(`/api/messaging/central-channels/${channelId}/details`);\n  }\n\n  /**\n   * Get channel participants\n   */\n  async getChannelParticipants(channelId: UUID): Promise<{ participants: ChannelParticipant[] }> {\n    return this.get<{ participants: ChannelParticipant[] }>(\n      `/api/messaging/central-channels/${channelId}/participants`\n    );\n  }\n\n  /**\n   * Add agent to channel\n   */\n  async addAgentToChannel(channelId: UUID, agentId: UUID): Promise<{ success: boolean }> {\n    return this.post<{ success: boolean }>(`/api/messaging/central-channels/${channelId}/agents`, {\n      agentId,\n    });\n  }\n\n  /**\n   * Remove agent from channel\n   */\n  async removeAgentFromChannel(channelId: UUID, agentId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(\n      `/api/messaging/central-channels/${channelId}/agents/${agentId}`\n    );\n  }\n\n  /**\n   * Delete a channel\n   */\n  async deleteChannel(channelId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(`/api/messaging/central-channels/${channelId}`);\n  }\n\n  /**\n   * Clear channel history\n   */\n  async clearChannelHistory(channelId: UUID): Promise<{ deleted: number }> {\n    return this.delete<{ deleted: number }>(\n      `/api/messaging/central-channels/${channelId}/messages`\n    );\n  }\n\n  /**\n   * Post a new message to a channel\n   */\n  async postMessage(\n    channelId: UUID,\n    content: string,\n    metadata?: Record<string, any>\n  ): Promise<Message> {\n    return this.post<Message>(`/api/messaging/central-channels/${channelId}/messages`, {\n      content,\n      metadata,\n    });\n  }\n\n  /**\n   * Get channel messages\n   */\n  async getChannelMessages(\n    channelId: UUID,\n    params?: PaginationParams & { before?: Date | string; after?: Date | string }\n  ): Promise<{ messages: Message[] }> {\n    return this.get<{ messages: Message[] }>(\n      `/api/messaging/central-channels/${channelId}/messages`,\n      { params }\n    );\n  }\n\n  /**\n   * Get a specific message\n   */\n  async getMessage(messageId: UUID): Promise<Message> {\n    return this.get<Message>(`/api/messaging/messages/${messageId}`);\n  }\n\n  /**\n   * Delete a message from a channel\n   */\n  async deleteMessage(channelId: UUID, messageId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(\n      `/api/messaging/central-channels/${channelId}/messages/${messageId}`\n    );\n  }\n\n  /**\n   * Update a message\n   */\n  async updateMessage(messageId: UUID, content: string): Promise<Message> {\n    return this.patch<Message>(`/api/messaging/messages/${messageId}`, { content });\n  }\n\n  /**\n   * Search messages\n   */\n  async searchMessages(params: MessageSearchParams): Promise<{ messages: Message[] }> {\n    return this.post<{ messages: Message[] }>('/api/messaging/messages/search', params);\n  }\n\n  /**\n   * List all message servers\n   */\n  async listServers(): Promise<{ servers: MessageServer[] }> {\n    return this.get<{ servers: MessageServer[] }>('/api/messaging/central-servers');\n  }\n\n  /**\n   * Get server channels\n   */\n  async getServerChannels(serverId: UUID): Promise<{ channels: MessageChannel[] }> {\n    return this.get<{ channels: MessageChannel[] }>(\n      `/api/messaging/central-servers/${serverId}/channels`\n    );\n  }\n\n  /**\n   * Create a new server\n   */\n  async createServer(params: ServerCreateParams): Promise<MessageServer> {\n    return this.post<MessageServer>('/api/messaging/servers', params);\n  }\n\n  /**\n   * Sync server channels\n   */\n  async syncServerChannels(serverId: UUID, params: ServerSyncParams): Promise<{ synced: number }> {\n    return this.post<{ synced: number }>(\n      `/api/messaging/servers/${serverId}/sync-channels`,\n      params\n    );\n  }\n\n  /**\n   * Delete a server\n   */\n  async deleteServer(serverId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(`/api/messaging/servers/${serverId}`);\n  }\n\n  /**\n   * Update a channel\n   */\n  async updateChannel(\n    channelId: UUID,\n    params: ChannelUpdateParams\n  ): Promise<{ success: boolean; data: MessageChannel }> {\n    return this.patch<{ success: boolean; data: MessageChannel }>(\n      `/api/messaging/central-channels/${channelId}`,\n      params\n    );\n  }\n\n  /**\n   * Generate channel title\n   */\n  async generateChannelTitle(channelId: UUID, agentId: UUID): Promise<{ title: string }> {\n    return this.post<{ title: string }>(\n      `/api/messaging/central-channels/${channelId}/generate-title`,\n      { agentId }\n    );\n  }\n\n  /**\n   * Add user to channel participants (implemented via updateChannel)\n   */\n  async addUserToChannel(\n    channelId: UUID,\n    userId: UUID\n  ): Promise<{ success: boolean; data: MessageChannel }> {\n    // First get current participants\n    const channel = await this.getChannelDetails(channelId);\n    const currentParticipants = channel.metadata?.participantCentralUserIds || [];\n\n    // Add new user if not already present\n    if (!currentParticipants.includes(userId)) {\n      const updatedParticipants = [...currentParticipants, userId];\n      return this.updateChannel(channelId, {\n        participantCentralUserIds: updatedParticipants,\n      });\n    }\n\n    return { success: true, data: channel };\n  }\n\n  /**\n   * Add multiple users to channel participants (implemented via updateChannel)\n   */\n  async addUsersToChannel(\n    channelId: UUID,\n    userIds: UUID[]\n  ): Promise<{ success: boolean; data: MessageChannel }> {\n    // First get current participants\n    const channel = await this.getChannelDetails(channelId);\n    const currentParticipants = channel.metadata?.participantCentralUserIds || [];\n\n    // Add new users that aren't already present\n    const newParticipants = [...currentParticipants];\n    for (const userId of userIds) {\n      if (!newParticipants.includes(userId)) {\n        newParticipants.push(userId);\n      }\n    }\n\n    return this.updateChannel(channelId, {\n      participantCentralUserIds: newParticipants,\n    });\n  }\n\n  /**\n   * Remove user from channel participants (implemented via updateChannel)\n   */\n  async removeUserFromChannel(\n    channelId: UUID,\n    userId: UUID\n  ): Promise<{ success: boolean; data: MessageChannel }> {\n    // First get current participants\n    const channel = await this.getChannelDetails(channelId);\n    const currentParticipants = channel.metadata?.participantCentralUserIds || [];\n\n    // Remove user from participants\n    const updatedParticipants = currentParticipants.filter((id) => id !== userId);\n\n    return this.updateChannel(channelId, {\n      participantCentralUserIds: updatedParticipants,\n    });\n  }\n}\n","import { UUID } from '@elizaos/core';\nimport { BaseApiClient } from '../lib/base-client';\nimport {\n  Memory,\n  Room,\n  MemoryParams,\n  MemoryUpdateParams,\n  RoomCreateParams,\n  WorldCreateParams,\n} from '../types/memory';\n\nexport class MemoryService extends BaseApiClient {\n  /**\n   * Get agent memories\n   */\n  async getAgentMemories(agentId: UUID, params?: MemoryParams): Promise<{ memories: Memory[] }> {\n    return this.get<{ memories: Memory[] }>(`/api/memory/${agentId}/memories`, { params });\n  }\n\n  /**\n   * Get room-specific memories\n   */\n  async getRoomMemories(\n    agentId: UUID,\n    roomId: UUID,\n    params?: MemoryParams\n  ): Promise<{ memories: Memory[] }> {\n    return this.get<{ memories: Memory[] }>(`/api/memory/${agentId}/rooms/${roomId}/memories`, {\n      params,\n    });\n  }\n\n  /**\n   * Update a memory\n   */\n  async updateMemory(agentId: UUID, memoryId: UUID, params: MemoryUpdateParams): Promise<Memory> {\n    return this.patch<Memory>(`/api/memory/${agentId}/memories/${memoryId}`, params);\n  }\n\n  /**\n   * Clear all agent memories\n   */\n  async clearAgentMemories(agentId: UUID): Promise<{ deleted: number }> {\n    return this.delete<{ deleted: number }>(`/api/memory/${agentId}/memories`);\n  }\n\n  /**\n   * Clear room memories\n   */\n  async clearRoomMemories(agentId: UUID, roomId: UUID): Promise<{ deleted: number }> {\n    return this.delete<{ deleted: number }>(`/api/memory/${agentId}/memories/all/${roomId}`);\n  }\n\n  /**\n   * List agent's rooms\n   */\n  async listAgentRooms(agentId: UUID): Promise<{ rooms: Room[] }> {\n    return this.get<{ rooms: Room[] }>(`/api/memory/${agentId}/rooms`);\n  }\n\n  /**\n   * Get room details\n   */\n  async getRoom(agentId: UUID, roomId: UUID): Promise<Room> {\n    return this.get<Room>(`/api/memory/${agentId}/rooms/${roomId}`);\n  }\n\n  /**\n   * Create a room\n   */\n  async createRoom(agentId: UUID, params: RoomCreateParams): Promise<Room> {\n    return this.post<Room>(`/api/memory/${agentId}/rooms`, params);\n  }\n\n  /**\n   * Create world from server\n   */\n  async createWorldFromServer(\n    serverId: UUID,\n    params: WorldCreateParams\n  ): Promise<{ worldId: UUID }> {\n    return this.post<{ worldId: UUID }>(`/api/memory/groups/${serverId}`, params);\n  }\n\n  /**\n   * Delete a world\n   */\n  async deleteWorld(serverId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(`/api/memory/groups/${serverId}`);\n  }\n\n  /**\n   * Clear world memories\n   */\n  async clearWorldMemories(serverId: UUID): Promise<{ deleted: number }> {\n    return this.delete<{ deleted: number }>(`/api/memory/groups/${serverId}/memories`);\n  }\n\n  /**\n   * Delete a specific memory\n   */\n  async deleteMemory(agentId: UUID, memoryId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(`/api/memory/${agentId}/memories/${memoryId}`);\n  }\n\n  /**\n   * Get agent internal memories\n   */\n  async getAgentInternalMemories(\n    agentId: UUID,\n    agentPerspectiveRoomId: UUID,\n    includeEmbedding?: boolean\n  ): Promise<{ success: boolean; data: any[] }> {\n    return this.get<{ success: boolean; data: any[] }>(\n      `/api/memory/${agentId}/rooms/${agentPerspectiveRoomId}/memories`,\n      { params: { includeEmbedding } }\n    );\n  }\n\n  /**\n   * Delete agent internal memory\n   */\n  async deleteAgentInternalMemory(agentId: UUID, memoryId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(`/api/memory/${agentId}/memories/${memoryId}`);\n  }\n\n  /**\n   * Delete all agent internal memories\n   */\n  async deleteAllAgentInternalMemories(\n    agentId: UUID,\n    agentPerspectiveRoomId: UUID\n  ): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(\n      `/api/memory/${agentId}/memories/all/${agentPerspectiveRoomId}`\n    );\n  }\n\n  /**\n   * Update agent internal memory\n   */\n  async updateAgentInternalMemory(agentId: UUID, memoryId: UUID, memoryData: any): Promise<any> {\n    return this.patch<any>(`/api/memory/${agentId}/memories/${memoryId}`, memoryData);\n  }\n\n  /**\n   * Delete group memory (implemented via messaging channel message deletion)\n   */\n  async deleteGroupMemory(serverId: UUID, memoryId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(\n      `/api/messaging/central-channels/${serverId}/messages/${memoryId}`\n    );\n  }\n\n  /**\n   * Clear group chat (implemented via messaging channel history clearing)\n   */\n  async clearGroupChat(serverId: UUID): Promise<{ success: boolean }> {\n    return this.delete<{ success: boolean }>(\n      `/api/messaging/central-channels/${serverId}/messages`\n    );\n  }\n}\n","import { UUID } from '@elizaos/core';\nimport { BaseApiClient } from '../lib/base-client';\nimport {\n  AudioSynthesizeParams,\n  SpeechConversationParams,\n  SpeechGenerateParams,\n  SpeechResponse,\n  TranscribeParams,\n  TranscriptionResponse,\n} from '../types/audio';\n\ndeclare const window: any;\n\nexport class AudioService extends BaseApiClient {\n  /**\n   * Make a binary request using BaseApiClient infrastructure\n   */\n  private async requestBinary(\n    method: string,\n    path: string,\n    options?: {\n      body?: any;\n      params?: Record<string, any>;\n      headers?: Record<string, string>;\n    }\n  ): Promise<ArrayBuffer> {\n    // Handle empty baseUrl for relative URLs\n    let url: URL;\n    if (this.baseUrl) {\n      url = new URL(`${this.baseUrl}${path}`);\n    } else if (typeof window !== 'undefined' && window.location) {\n      url = new URL(path, window.location.origin);\n    } else {\n      // Fallback for non-browser environments\n      url = new URL(path, 'http://localhost:3000');\n    }\n\n    // Add query parameters\n    if (options?.params) {\n      Object.entries(options.params).forEach(([key, value]) => {\n        if (value !== undefined && value !== null) {\n          url.searchParams.append(key, String(value));\n        }\n      });\n    }\n\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n    try {\n      const headers = {\n        ...this.defaultHeaders,\n        ...options?.headers,\n      };\n\n      // Remove Content-Type header if body is FormData\n      if (options?.body instanceof FormData) {\n        delete headers['Content-Type'];\n      }\n\n      const response = await fetch(url.toString(), {\n        method,\n        headers,\n        body:\n          options?.body instanceof FormData\n            ? options.body\n            : options?.body\n              ? JSON.stringify(options.body)\n              : undefined,\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      return await response.arrayBuffer();\n    } catch (error) {\n      clearTimeout(timeoutId);\n\n      if (error instanceof Error) {\n        if (error.name === 'AbortError') {\n          throw new Error('Request timed out');\n        }\n        throw error;\n      }\n\n      throw new Error('An unknown error occurred');\n    }\n  }\n\n  /**\n   * Convert audio input to appropriate FormData value\n   */\n  private processAudioInput(audio: Blob | Buffer | string): Blob | string {\n    if (audio instanceof Blob) {\n      return audio;\n    }\n\n    if (typeof audio === 'string') {\n      // Handle base64 data URLs (e.g., \"data:audio/mp3;base64,...\")\n      if (audio.startsWith('data:')) {\n        try {\n          const [header, base64Data] = audio.split(',');\n          const mimeMatch = header.match(/data:([^;]+)/);\n          const mimeType = mimeMatch ? mimeMatch[1] : 'audio/wav';\n\n          const binaryString = atob(base64Data);\n          const bytes = new Uint8Array(binaryString.length);\n          for (let i = 0; i < binaryString.length; i++) {\n            bytes[i] = binaryString.charCodeAt(i);\n          }\n          return new Blob([bytes], { type: mimeType });\n        } catch (error) {\n          throw new Error(\n            `Invalid base64 data URL: ${error instanceof Error ? error.message : 'Unknown error'}`\n          );\n        }\n      }\n\n      // Handle plain base64 strings (try to decode)\n      if (this.isBase64String(audio)) {\n        try {\n          const binaryString = atob(audio);\n          const bytes = new Uint8Array(binaryString.length);\n          for (let i = 0; i < binaryString.length; i++) {\n            bytes[i] = binaryString.charCodeAt(i);\n          }\n          return new Blob([bytes], { type: 'audio/wav' });\n        } catch (error) {\n          // If base64 decoding fails, treat as file path or other string\n          return audio;\n        }\n      }\n\n      // For file paths or other strings, return as-is (server will handle file reading)\n      return audio;\n    }\n\n    // Handle Buffer and ArrayBuffer types\n    if (this.isBuffer(audio)) {\n      return new Blob([audio], { type: 'audio/wav' });\n    }\n\n    // Cast to any for runtime type checking since TypeScript can't narrow the union type properly\n    const audioAsAny = audio as any;\n\n    if (audioAsAny instanceof ArrayBuffer) {\n      return new Blob([audioAsAny], { type: 'audio/wav' });\n    }\n\n    if (\n      audioAsAny &&\n      typeof audioAsAny === 'object' &&\n      'buffer' in audioAsAny &&\n      audioAsAny.buffer instanceof ArrayBuffer\n    ) {\n      // Handle typed arrays like Uint8Array\n      return new Blob([audioAsAny.buffer], { type: 'audio/wav' });\n    }\n\n    throw new Error(\n      `Unsupported audio input type: ${typeof audio}. Expected Blob, Buffer, ArrayBuffer, or string.`\n    );\n  }\n\n  /**\n   * Check if a string appears to be base64 encoded\n   */\n  private isBase64String(str: string): boolean {\n    // Basic base64 pattern check (allows padding)\n    const base64Pattern = /^[A-Za-z0-9+/]*={0,2}$/;\n\n    // Must be at least 4 characters and divisible by 4 (with padding)\n    if (str.length < 4 || str.length % 4 !== 0) {\n      return false;\n    }\n\n    return base64Pattern.test(str);\n  }\n\n  /**\n   * Safe check for Buffer type (works in both Node.js and browser environments)\n   */\n  private isBuffer(obj: any): obj is Buffer {\n    return (\n      obj != null &&\n      typeof obj === 'object' &&\n      typeof obj.constructor === 'function' &&\n      obj.constructor.name === 'Buffer' &&\n      typeof obj.readUInt8 === 'function'\n    );\n  }\n\n  /**\n   * Handle speech conversation\n   */\n  async speechConversation(\n    agentId: UUID,\n    params: SpeechConversationParams\n  ): Promise<SpeechResponse> {\n    const formData = new FormData();\n\n    const processedAudio = this.processAudioInput(params.audio);\n    if (processedAudio instanceof Blob) {\n      formData.append('file', processedAudio);\n    } else {\n      // String (file path or other string identifier)\n      formData.append('file', processedAudio);\n    }\n\n    if (params.format) formData.append('format', params.format);\n    if (params.language) formData.append('language', params.language);\n    if (params.metadata) formData.append('metadata', JSON.stringify(params.metadata));\n\n    return this.request<SpeechResponse>('POST', `/api/audio/${agentId}/speech/conversation`, {\n      body: formData,\n    });\n  }\n\n  /**\n   * Generate speech from text\n   */\n  async generateSpeech(\n    agentId: UUID,\n    params: SpeechGenerateParams\n  ): Promise<{ audio: string; format: string }> {\n    // Get the binary audio data using BaseApiClient infrastructure\n    const audioBuffer = await this.requestBinary('POST', `/api/audio/${agentId}/speech/generate`, {\n      body: params,\n    });\n\n    // Convert to base64\n    const bytes = new Uint8Array(audioBuffer);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    const base64Audio = btoa(binary);\n\n    // Default format (server should ideally return this in a header)\n    const format = 'mpeg';\n\n    return {\n      audio: base64Audio,\n      format: format,\n    };\n  }\n\n  /**\n   * Synthesize audio message\n   */\n  async synthesizeAudioMessage(\n    agentId: UUID,\n    params: AudioSynthesizeParams\n  ): Promise<{ audio: string; format: string }> {\n    return this.post<{ audio: string; format: string }>(\n      `/api/audio/${agentId}/audio-messages/synthesize`,\n      params\n    );\n  }\n\n  /**\n   * Transcribe audio to text\n   */\n  async transcribe(agentId: UUID, params: TranscribeParams): Promise<TranscriptionResponse> {\n    const formData = new FormData();\n\n    const processedAudio = this.processAudioInput(params.audio);\n    if (processedAudio instanceof Blob) {\n      formData.append('file', processedAudio);\n    } else {\n      // String (file path or other string identifier)\n      formData.append('file', processedAudio);\n    }\n\n    if (params.format) formData.append('format', params.format);\n    if (params.language) formData.append('language', params.language);\n\n    return this.request<TranscriptionResponse>('POST', `/api/audio/${agentId}/transcriptions`, {\n      body: formData,\n    });\n  }\n\n  /**\n   * Process speech input\n   */\n  async processSpeech(\n    agentId: UUID,\n    audio: Blob | Buffer | string,\n    metadata?: Record<string, any>\n  ): Promise<SpeechResponse> {\n    const formData = new FormData();\n\n    const processedAudio = this.processAudioInput(audio);\n    if (processedAudio instanceof Blob) {\n      formData.append('file', processedAudio);\n    } else {\n      // String (file path or other string identifier)\n      formData.append('file', processedAudio);\n    }\n\n    if (metadata) formData.append('metadata', JSON.stringify(metadata));\n\n    return this.request<SpeechResponse>('POST', `/api/audio/${agentId}/speech`, {\n      body: formData,\n    });\n  }\n}\n","import { UUID } from '@elizaos/core';\nimport { BaseApiClient } from '../lib/base-client';\nimport { MediaUploadParams, MediaUploadResponse, ChannelUploadResponse } from '../types/media';\n\nexport class MediaService extends BaseApiClient {\n  /**\n   * Upload media for an agent\n   */\n  async uploadAgentMedia(agentId: UUID, params: MediaUploadParams): Promise<MediaUploadResponse> {\n    const formData = new FormData();\n\n    formData.append('file', params.file, params.filename);\n\n    if (params.contentType) formData.append('contentType', params.contentType);\n    if (params.metadata) formData.append('metadata', JSON.stringify(params.metadata));\n\n    return this.request<MediaUploadResponse>('POST', `/api/media/agents/${agentId}/upload-media`, {\n      body: formData,\n    });\n  }\n\n  /**\n   * Upload file to a channel\n   */\n  async uploadChannelMedia(channelId: UUID, file: File): Promise<ChannelUploadResponse> {\n    const formData = new FormData();\n\n    formData.append('file', file);\n\n    return this.request<ChannelUploadResponse>(\n      'POST',\n      `/api/messaging/central-channels/${channelId}/upload-media`,\n      {\n        body: formData,\n      }\n    );\n  }\n}\n","import { BaseApiClient } from '../lib/base-client';\nimport { ServerHealth, ServerStatus, ServerDebugInfo, LogSubmitParams } from '../types/server';\n\nexport class ServerService extends BaseApiClient {\n  /**\n   * Health check\n   */\n  async checkHealth(): Promise<ServerHealth> {\n    return this.get<ServerHealth>('/api/server/health');\n  }\n\n  /**\n   * Simple ping\n   */\n  async ping(): Promise<{ pong: boolean }> {\n    return this.get<{ pong: boolean }>('/api/server/ping');\n  }\n\n  /**\n   * Hello endpoint\n   */\n  async hello(): Promise<{ message: string }> {\n    return this.get<{ message: string }>('/api/server/hello');\n  }\n\n  /**\n   * Get server status\n   */\n  async getStatus(): Promise<ServerStatus> {\n    return this.get<ServerStatus>('/api/server/status');\n  }\n\n  /**\n   * Stop the server\n   */\n  async stopServer(): Promise<{ success: boolean }> {\n    return this.post<{ success: boolean }>('/api/server/stop');\n  }\n\n  /**\n   * Get runtime debug info\n   */\n  async getDebugInfo(): Promise<ServerDebugInfo> {\n    return this.get<ServerDebugInfo>('/api/server/debug/servers');\n  }\n\n  /**\n   * Submit logs\n   */\n  async submitLogs(logs: LogSubmitParams[]): Promise<{ received: number }> {\n    return this.post<{ received: number }>('/api/server/logs', { logs });\n  }\n\n  /**\n   * Clear logs\n   */\n  async clearLogs(): Promise<{ cleared: number }> {\n    return this.delete<{ cleared: number }>('/api/server/logs');\n  }\n}\n","import { BaseApiClient } from '../lib/base-client';\nimport { LocalEnvironmentUpdateParams } from '../types/system';\n\nexport class SystemService extends BaseApiClient {\n  /**\n   * Retrieve the local environment variables from the ElizaOS server.\n   *\n   * Server route (packages/server/src/api/system):\n   *   GET /api/system/env/local  ->  { success: true, data: Record<string,string> }\n   */\n  async getEnvironment(): Promise<Record<string, string>> {\n    return this.get<Record<string, string>>('/api/system/env/local');\n  }\n\n  /**\n   * Update (overwrite or merge) the local .env file on the ElizaOS server.\n   *\n   * Server route (packages/server/src/api/system):\n   *   POST /api/system/env/local  ->  { success: true, message: string }\n   *   Body: { content: Record<string,string> }\n   *\n   * For developer-ergonomics we accept several shapes:\n   *   1. { variables: Record<string,string>; merge?: boolean }\n   *   2. { content:   Record<string,string> }      (server-native)\n   *   3. Record<string,string>                      (shorthand)\n   */\n  async updateLocalEnvironment(\n    params:\n      | LocalEnvironmentUpdateParams\n      | { content: Record<string, string> }\n      | Record<string, string>\n  ): Promise<{ success: boolean; message: string }> {\n    if (!params || typeof params !== 'object') {\n      throw new Error('updateLocalEnvironment requires a configuration object');\n    }\n\n    let body: { content: Record<string, string> };\n\n    if ('variables' in params) {\n      body = { content: (params as LocalEnvironmentUpdateParams).variables };\n    } else if ('content' in params) {\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n      body = { content: (params as { content: Record<string, string> }).content };\n    } else {\n      // Treat params itself as record of env vars\n      body = { content: params as unknown as Record<string, string> };\n    }\n\n    return this.post<{ success: boolean; message: string }>('/api/system/env/local', body);\n  }\n\n  /**\n   * Global logs functionality - implementing via system endpoints\n   */\n  async getGlobalLogs(params?: { level?: string; agentName?: string; agentId?: string }): Promise<{\n    logs: Array<{\n      level: number;\n      time: number;\n      msg: string;\n      [key: string]: string | number | boolean | null | undefined;\n    }>;\n    count: number;\n    total: number;\n    level: string;\n    levels: string[];\n  }> {\n    // Special handling for logs endpoint that returns data directly without wrapper\n    const response = await fetch(this.buildUrl('/api/server/logs', { params }), {\n      method: 'GET',\n      headers: this.getHeaders(),\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n\n    const data = (await response.json()) as {\n      logs?: Array<{\n        level: number;\n        time: number;\n        msg: string;\n        [key: string]: string | number | boolean | null | undefined;\n      }>;\n      count?: number;\n      total?: number;\n      requestedLevel?: string;\n      level?: string;\n      levels?: string[];\n    };\n\n    // The logs endpoint returns data directly, not wrapped in { success, data }\n    // Map the response to expected format\n    return {\n      logs: data.logs || [],\n      count: data.count || 0,\n      total: data.total || 0,\n      level: data.requestedLevel || data.level || 'all',\n      levels: data.levels || [],\n    };\n  }\n\n  private buildUrl(path: string, options?: { params?: Record<string, any> }): string {\n    const url = new URL(`${this.baseUrl}${path}`);\n    if (options?.params) {\n      Object.entries(options.params).forEach(([key, value]) => {\n        if (value !== undefined && value !== null) {\n          url.searchParams.append(key, String(value));\n        }\n      });\n    }\n    return url.toString();\n  }\n\n  private getHeaders(): Record<string, string> {\n    return {\n      ...this.defaultHeaders,\n    };\n  }\n\n  async deleteGlobalLogs(): Promise<{ status: string; message: string }> {\n    return this.delete<{ status: string; message: string }>('/api/server/logs');\n  }\n\n  async deleteLog(logId: string): Promise<void> {\n    // Note: Individual log deletion is not supported by the server\n    // The server only supports bulk deletion via deleteGlobalLogs()\n    throw new Error(\n      'Individual log deletion is not supported. Use deleteGlobalLogs() to clear all logs.'\n    );\n  }\n}\n","import { BaseApiClient } from '../lib/base-client';\nimport type {\n  CreateSessionParams,\n  CreateSessionResponse,\n  SendMessageParams,\n  GetMessagesParams,\n  GetMessagesResponse,\n  SessionInfoResponse,\n  SessionsHealthResponse,\n  ListSessionsResponse,\n  MessageResponse,\n} from '../types/sessions';\n\n/**\n * Query parameters for session messages API\n */\ninterface SessionMessageQueryParams {\n  limit?: string;\n  before?: string;\n  after?: string;\n}\n\n/**\n * Validates and converts a date parameter to timestamp string\n * @param value Date, string, or number to convert\n * @param paramName Name of the parameter for error messages\n * @returns Timestamp string or undefined if value is invalid\n */\nfunction toTimestampString(\n  value: Date | string | number | undefined,\n  paramName: string\n): string | undefined {\n  if (!value) return undefined;\n\n  let timestamp: number;\n\n  if (value instanceof Date) {\n    timestamp = value.getTime();\n  } else if (typeof value === 'string') {\n    const date = new Date(value);\n    timestamp = date.getTime();\n\n    // Check for invalid date\n    if (isNaN(timestamp)) {\n      console.warn(`Invalid date string for ${paramName}: ${value}`);\n      return undefined;\n    }\n  } else if (typeof value === 'number') {\n    timestamp = value;\n  } else {\n    console.warn(`Invalid type for ${paramName}: ${typeof value}`);\n    return undefined;\n  }\n\n  return timestamp.toString();\n}\n\n/**\n * Validates required parameters\n * @param value Parameter value to validate\n * @param paramName Name of the parameter for error messages\n * @throws Error if the parameter is invalid\n */\nfunction validateRequiredParam(\n  value: string | undefined | null,\n  paramName: string\n): asserts value is string {\n  if (!value || value.trim() === '') {\n    throw new Error(`${paramName} is required and cannot be empty`);\n  }\n}\n\n/**\n * Service for managing messaging sessions between users and agents\n */\nexport class SessionsService extends BaseApiClient {\n  /**\n   * Get health status of the sessions service\n   * @returns Health check response\n   */\n  async checkHealth(): Promise<SessionsHealthResponse> {\n    return this.get<SessionsHealthResponse>('/api/messaging/sessions/health');\n  }\n\n  /**\n   * Create a new messaging session\n   * @param params Session creation parameters\n   * @returns Created session response\n   */\n  async createSession(params: CreateSessionParams): Promise<CreateSessionResponse> {\n    return this.post<CreateSessionResponse>('/api/messaging/sessions', params);\n  }\n\n  /**\n   * Get session details\n   * @param sessionId Session ID\n   * @returns Session information\n   */\n  async getSession(sessionId: string): Promise<SessionInfoResponse> {\n    validateRequiredParam(sessionId, 'sessionId');\n    return this.get<SessionInfoResponse>(`/api/messaging/sessions/${sessionId}`);\n  }\n\n  /**\n   * Send a message in a session\n   * @param sessionId Session ID\n   * @param params Message parameters\n   * @returns Message response\n   */\n  async sendMessage(sessionId: string, params: SendMessageParams): Promise<MessageResponse> {\n    validateRequiredParam(sessionId, 'sessionId');\n    validateRequiredParam(params?.content, 'content');\n    return this.post<MessageResponse>(`/api/messaging/sessions/${sessionId}/messages`, params);\n  }\n\n  /**\n   * Get messages from a session\n   * @param sessionId Session ID\n   * @param params Query parameters for pagination and filtering\n   * @returns Messages response\n   */\n  async getMessages(sessionId: string, params?: GetMessagesParams): Promise<GetMessagesResponse> {\n    validateRequiredParam(sessionId, 'sessionId');\n\n    const queryParams: SessionMessageQueryParams = {};\n\n    if (params?.limit) {\n      queryParams.limit = params.limit.toString();\n    }\n\n    // Convert date parameters with validation\n    const beforeTimestamp = toTimestampString(params?.before, 'before');\n    if (beforeTimestamp) {\n      queryParams.before = beforeTimestamp;\n    }\n\n    const afterTimestamp = toTimestampString(params?.after, 'after');\n    if (afterTimestamp) {\n      queryParams.after = afterTimestamp;\n    }\n\n    return this.get<GetMessagesResponse>(`/api/messaging/sessions/${sessionId}/messages`, {\n      params: queryParams,\n    });\n  }\n\n  /**\n   * Delete a session\n   * @param sessionId Session ID\n   * @returns Success response\n   */\n  async deleteSession(sessionId: string): Promise<{ success: boolean }> {\n    validateRequiredParam(sessionId, 'sessionId');\n    return this.delete<{ success: boolean }>(`/api/messaging/sessions/${sessionId}`);\n  }\n\n  /**\n   * List all active sessions (admin endpoint)\n   * @returns List of active sessions\n   */\n  async listSessions(): Promise<ListSessionsResponse> {\n    return this.get<ListSessionsResponse>('/api/messaging/sessions');\n  }\n}\n","import { ApiClientConfig } from './types/base';\nimport { AgentsService } from './services/agents';\nimport { MessagingService } from './services/messaging';\nimport { MemoryService } from './services/memory';\nimport { AudioService } from './services/audio';\nimport { MediaService } from './services/media';\nimport { ServerService } from './services/server';\nimport { SystemService } from './services/system';\nimport { SessionsService } from './services/sessions';\n\nexport class ElizaClient {\n  public readonly agents: AgentsService;\n  public readonly messaging: MessagingService;\n  public readonly memory: MemoryService;\n  public readonly audio: AudioService;\n  public readonly media: MediaService;\n  public readonly server: ServerService;\n  public readonly system: SystemService;\n  public readonly sessions: SessionsService;\n\n  constructor(config: ApiClientConfig) {\n    // Initialize all services with the same config\n    this.agents = new AgentsService(config);\n    this.messaging = new MessagingService(config);\n    this.memory = new MemoryService(config);\n    this.audio = new AudioService(config);\n    this.media = new MediaService(config);\n    this.server = new ServerService(config);\n    this.system = new SystemService(config);\n    this.sessions = new SessionsService(config);\n  }\n\n  /**\n   * Create a new ElizaClient instance\n   */\n  static create(config: ApiClientConfig): ElizaClient {\n    return new ElizaClient(config);\n  }\n}\n"],"mappings":"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","names":[]}