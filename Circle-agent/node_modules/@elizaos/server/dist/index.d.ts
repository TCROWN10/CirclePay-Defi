import { UUID, ChannelType, Character, DatabaseAdapter, IAgentRuntime } from '@elizaos/core';
import express from 'express';
import http from 'node:http';
import { Server } from 'socket.io';

/**
 * Metadata associated with a session
 */
interface SessionMetadata {
    platform?: string;
    username?: string;
    discriminator?: string;
    avatar?: string;
    [key: string]: string | number | boolean | undefined;
}
/**
 * Represents a messaging session between a user and an agent
 */
interface Session {
    id: string;
    agentId: UUID;
    channelId: UUID;
    userId: UUID;
    metadata: SessionMetadata;
    createdAt: Date;
    lastActivity: Date;
}
/**
 * Request body for creating a session
 */
interface CreateSessionRequest {
    agentId: string;
    userId: string;
    metadata?: SessionMetadata;
}
/**
 * Response for session creation
 */
interface CreateSessionResponse {
    sessionId: string;
    agentId: UUID;
    userId: UUID;
    createdAt: Date;
    metadata: SessionMetadata;
}
/**
 * Request body for sending a message
 */
interface SendMessageRequest {
    content: string;
    attachments?: Array<{
        type: string;
        url: string;
        name?: string;
    }>;
    metadata?: Record<string, any>;
}
/**
 * Query parameters for retrieving messages
 */
interface GetMessagesQuery {
    limit?: string;
    before?: string;
    after?: string;
}
/**
 * Simplified message format for API responses
 */
interface SimplifiedMessage {
    id: string;
    content: string;
    authorId: string;
    isAgent: boolean;
    createdAt: Date;
    metadata: {
        thought?: string;
        actions?: string[];
        [key: string]: any;
    };
}
/**
 * Response for message retrieval
 */
interface GetMessagesResponse {
    messages: SimplifiedMessage[];
    hasMore: boolean;
}
/**
 * Session info response
 */
interface SessionInfoResponse {
    sessionId: string;
    agentId: UUID;
    userId: UUID;
    createdAt: Date;
    lastActivity: Date;
    metadata: SessionMetadata;
}
/**
 * Health check response
 */
interface HealthCheckResponse {
    status: 'healthy' | 'unhealthy';
    activeSessions: number;
    timestamp: string;
}

interface MessageServer {
    id: UUID;
    name: string;
    sourceType: string;
    sourceId?: string;
    metadata?: Record<string, any>;
    createdAt: Date;
    updatedAt: Date;
}
interface MessageChannel {
    id: UUID;
    messageServerId: UUID;
    name: string;
    type: ChannelType;
    sourceType?: string;
    sourceId?: string;
    topic?: string;
    metadata?: Record<string, any>;
    createdAt: Date;
    updatedAt: Date;
}
interface CentralRootMessage {
    id: UUID;
    channelId: UUID;
    authorId: UUID;
    content: string;
    rawMessage?: any;
    inReplyToRootMessageId?: UUID;
    sourceType?: string;
    sourceId?: string;
    createdAt: Date;
    updatedAt: Date;
    metadata?: Record<string, any>;
}
interface MessageServiceStructure {
    id: UUID;
    channel_id: UUID;
    server_id: UUID;
    author_id: UUID;
    author_display_name?: string;
    content: string;
    raw_message?: any;
    source_id?: string;
    source_type?: string;
    in_reply_to_message_id?: UUID;
    created_at: number;
    metadata?: any;
}

/**
 * Attempts to load a file from the given file path.
 *
 * @param {string} filePath - The path to the file to load.
 * @returns {string | null} The contents of the file as a string, or null if an error occurred.
 * @throws {Error} If an error occurs while loading the file.
 */
declare function tryLoadFile(filePath: string): string | null;
/**
 * Load characters from a specified URL and return them as an array of Character objects.
 * @param {string} url - The URL from which to load character data.
 * @returns {Promise<Character[]>} - A promise that resolves with an array of Character objects.
 */
declare function loadCharactersFromUrl(url: string): Promise<Character[]>;
/**
 * Converts a JSON object representing a character into a validated Character object with additional settings and secrets.
 *
 * @param {unknown} character - The input data representing a character.
 * @returns {Promise<Character>} - A Promise that resolves to a validated Character object.
 * @throws {Error} If character validation fails.
 */
declare function jsonToCharacter(character: unknown): Promise<Character>;
/**
 * Loads a character from the specified file path with safe JSON parsing and validation.
 *
 * @param {string} filePath - The path to the character file.
 * @returns {Promise<Character>} A Promise that resolves to the validated Character object.
 * @throws {Error} If the character file is not found, has invalid JSON, or fails validation.
 */
declare function loadCharacter(filePath: string): Promise<Character>;
/**
 * Asynchronously loads a character from the specified path.
 * If the path is a URL, it loads the character from the URL.
 * If the path is a local file path, it tries multiple possible locations and
 * loads the character from the first valid location found.
 *
 * @param {string} characterPath - The path to load the character from.
 * @returns {Promise<Character>} A Promise that resolves to the loaded character.
 */
declare function loadCharacterTryPath(characterPath: string): Promise<Character>;
declare const hasValidRemoteUrls: () => boolean | "" | undefined;
/**
 * Load characters from local paths or remote URLs based on configuration.
 * @param charactersArg - A comma-separated list of local file paths or remote URLs to load characters from.
 * @returns A promise that resolves to an array of loaded characters.
 */
declare function loadCharacters(charactersArg: string): Promise<Character[]>;

/**
 * Expands a file path starting with `~` to the project directory.
 *
 * @param filepath - The path to expand.
 * @returns The expanded path.
 */
declare function expandTildePath(filepath: string): string;
declare function resolvePgliteDir(dir?: string, fallbackDir?: string): string;
/**
 * Represents a function that acts as a server middleware.
 * @param {express.Request} req - The request object.
 * @param {express.Response} res - The response object.
 * @param {express.NextFunction} next - The next function to be called in the middleware chain.
 * @returns {void}
 */
type ServerMiddleware = (req: express.Request, res: express.Response, next: express.NextFunction) => void;
/**
 * Interface for defining server configuration options.
 * @typedef {Object} ServerOptions
 * @property {ServerMiddleware[]} [middlewares] - Optional array of server middlewares.
 * @property {string} [dataDir] - Optional directory for storing server data.
 * @property {string} [postgresUrl] - Optional URL for connecting to a PostgreSQL database.
 */
interface ServerOptions {
    middlewares?: ServerMiddleware[];
    dataDir?: string;
    postgresUrl?: string;
    clientPath?: string;
}
/**
 * Determines if the web UI should be enabled based on environment variables.
 *
 * @returns {boolean} - Returns true if UI should be enabled, false otherwise
 */
declare function isWebUIEnabled(): boolean;
/**
 * Class representing an agent server.
 */ /**
* Represents an agent server which handles agents, database, and server functionalities.
*/
declare class AgentServer {
    app: express.Application;
    private agents;
    server: http.Server;
    socketIO: Server;
    isInitialized: boolean;
    private isWebUIEnabled;
    private clientPath?;
    database: DatabaseAdapter;
    startAgent: (character: Character) => Promise<IAgentRuntime>;
    stopAgent: (runtime: IAgentRuntime) => void;
    loadCharacterTryPath: (characterPath: string) => Promise<Character>;
    jsonToCharacter: (character: unknown) => Promise<Character>;
    /**
     * Constructor for AgentServer class.
     *
     * @constructor
     */
    constructor();
    /**
     * Initializes the database and server.
     *
     * @param {ServerOptions} [options] - Optional server options.
     * @returns {Promise<void>} A promise that resolves when initialization is complete.
     */
    initialize(options?: ServerOptions): Promise<void>;
    private ensureDefaultServer;
    /**
     * Initializes the server with the provided options.
     *
     * @param {ServerOptions} [options] - Optional server options.
     * @returns {Promise<void>} - A promise that resolves once the server is initialized.
     */
    private initializeServer;
    /**
     * Registers an agent with the provided runtime.
     *
     * @param {IAgentRuntime} runtime - The runtime object containing agent information.
     * @throws {Error} if the runtime is null/undefined, if agentId is missing, if character configuration is missing,
     * or if there are any errors during registration.
     */
    registerAgent(runtime: IAgentRuntime): Promise<void>;
    /**
     * Unregisters an agent from the system.
     *
     * @param {UUID} agentId - The unique identifier of the agent to unregister.
     * @returns {void}
     */
    unregisterAgent(agentId: UUID): void;
    /**
     * Add middleware to the server's request handling pipeline
     * @param {ServerMiddleware} middleware - The middleware function to be registered
     */
    registerMiddleware(middleware: ServerMiddleware): void;
    /**
     * Starts the server on the specified port.
     *
     * @param {number} port - The port number on which the server should listen.
     * @returns {Promise<void>} A promise that resolves when the server is listening.
     * @throws {Error} If the port is invalid or if there is an error while starting the server.
     */
    start(port: number): Promise<void>;
    /**
     * Stops the server if it is running. Closes the server connection,
     * stops the database connection, and logs a success message.
     */
    stop(): Promise<void>;
    createServer(data: Omit<MessageServer, 'id' | 'createdAt' | 'updatedAt'>): Promise<MessageServer>;
    getServers(): Promise<MessageServer[]>;
    getServerById(serverId: UUID): Promise<MessageServer | null>;
    getServerBySourceType(sourceType: string): Promise<MessageServer | null>;
    createChannel(data: Omit<MessageChannel, 'id' | 'createdAt' | 'updatedAt'> & {
        id?: UUID;
    }, participantIds?: UUID[]): Promise<MessageChannel>;
    addParticipantsToChannel(channelId: UUID, userIds: UUID[]): Promise<void>;
    getChannelsForServer(serverId: UUID): Promise<MessageChannel[]>;
    getChannelDetails(channelId: UUID): Promise<MessageChannel | null>;
    getChannelParticipants(channelId: UUID): Promise<UUID[]>;
    deleteMessage(messageId: UUID): Promise<void>;
    updateChannel(channelId: UUID, updates: {
        name?: string;
        participantCentralUserIds?: UUID[];
        metadata?: any;
    }): Promise<MessageChannel>;
    deleteChannel(channelId: UUID): Promise<void>;
    clearChannelMessages(channelId: UUID): Promise<void>;
    findOrCreateCentralDmChannel(user1Id: UUID, user2Id: UUID, messageServerId: UUID): Promise<MessageChannel>;
    createMessage(data: Omit<CentralRootMessage, 'id' | 'createdAt' | 'updatedAt'>): Promise<CentralRootMessage>;
    getMessagesForChannel(channelId: UUID, limit?: number, beforeTimestamp?: Date): Promise<CentralRootMessage[]>;
    removeParticipantFromChannel(): Promise<void>;
    /**
     * Add an agent to a server
     * @param {UUID} serverId - The server ID
     * @param {UUID} agentId - The agent ID to add
     */
    addAgentToServer(serverId: UUID, agentId: UUID): Promise<void>;
    /**
     * Remove an agent from a server
     * @param {UUID} serverId - The server ID
     * @param {UUID} agentId - The agent ID to remove
     */
    removeAgentFromServer(serverId: UUID, agentId: UUID): Promise<void>;
    /**
     * Get all agents associated with a server
     * @param {UUID} serverId - The server ID
     * @returns {Promise<UUID[]>} Array of agent IDs
     */
    getAgentsForServer(serverId: UUID): Promise<UUID[]>;
    /**
     * Get all servers an agent belongs to
     * @param {UUID} agentId - The agent ID
     * @returns {Promise<UUID[]>} Array of server IDs
     */
    getServersForAgent(agentId: UUID): Promise<UUID[]>;
    /**
     * Registers signal handlers for graceful shutdown.
     * This is called once in the constructor to prevent handler accumulation.
     */
    private registerSignalHandlers;
}

export { AgentServer, type CentralRootMessage, type CreateSessionRequest, type CreateSessionResponse, type GetMessagesQuery, type GetMessagesResponse, type HealthCheckResponse, type MessageChannel, type MessageServer, type MessageServiceStructure, type SendMessageRequest, type ServerMiddleware, type ServerOptions, type Session, type SessionInfoResponse, type SessionMetadata, type SimplifiedMessage, expandTildePath, hasValidRemoteUrls, isWebUIEnabled, jsonToCharacter, loadCharacter, loadCharacterTryPath, loadCharacters, loadCharactersFromUrl, resolvePgliteDir, tryLoadFile };
